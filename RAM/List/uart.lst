###############################################################################
#                                                                             #
#                                                       27/Apr/2013  13:36:04 #
# IAR ANSI C/C++ Compiler V6.30.4.23288/W32 EVALUATION for ARM                #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送      #
#                    接受 像素处理  死机\src\Sources\Drivers\uart\uart.c      #
#    Command line =  "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\src\Sources\Drivers\uart\uart.c"     #
#                    -lCN "C:\Users\Administrator\Desktop\4.25屏幕 下位机     #
#                    发送 接受 像素处理  死机\RAM\List\" -lB                  #
#                    "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\RAM\List\" -o                        #
#                    "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\RAM\Obj\" --no_cse --no_unroll       #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\src\Sources\Cpu\" -I                 #
#                    "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\src\Sources\App\" -I                 #
#                    "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\src\Sources\Drivers\adc\" -I         #
#                    "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\src\Sources\Drivers\delay\" -I       #
#                    "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\src\Sources\Drivers\FTM\" -I         #
#                    "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\src\Sources\Drivers\gpio\" -I        #
#                    "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\src\Sources\Drivers\lptmr\" -I       #
#                    "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\src\Sources\Drivers\mcg\" -I         #
#                    "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\src\Sources\Drivers\PIT\" -I         #
#                    "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\src\Sources\Drivers\uart\" -I        #
#                    "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\src\Sources\Drivers\oled\" -I        #
#                    "C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送     #
#                    接受 像素处理  死机\src\Sources\Drivers\spi\" -On        #
#                    --use_c++_inline                                         #
#    List file    =  C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送      #
#                    接受 像素处理  死机\RAM\List\uart.lst                    #
#    Object file  =  C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送      #
#                    接受 像素处理  死机\RAM\Obj\uart.o                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\4.25屏幕 下位机 发送 接受 像素处理  死机\src\Sources\Drivers\uart\uart.c
      1          /******************** (C) COPYRIGHT 2011 野火嵌入式开发工作室 ********************
      2           * 文件名       ：uart.c
      3           * 描述         ：串口函数
      4           * 备注         ：参考苏州大学的例程和飞思卡尔官方的例程
      5           *
      6           * 实验平台     ：野火kinetis开发板
      7           * 库版本       ：
      8           * 嵌入系统     ：
      9           *
     10           * 作者         ：
     11           * 淘宝店       ：http://firestm32.taobao.com
     12           * 技术支持论坛 ：http://www.ourdev.cn/bbs/bbs_list.jsp?bbs_id=1008
     13          **********************************************************************************/
     14          
     15          #include "common.h"
     16          #include "uart.h"
     17          #include "assert.h"
     18          

   \                                 In section .data, align 4
     19          volatile struct UART_MemMap *UARTx[6] = {UART0_BASE_PTR, UART1_BASE_PTR, UART2_BASE_PTR, UART3_BASE_PTR, UART4_BASE_PTR, UART5_BASE_PTR}; //定义五个指针数组保存 UARTx 的地址
   \                     UARTx:
   \   00000000   0x4006A000         DC32 4006A000H, 4006B000H, 4006C000H, 4006D000H, 400EA000H, 400EB000H
   \              0x4006B000   
   \              0x4006C000   
   \              0x4006D000   
   \              0x400EA000   
   \              0x400EB000   
     20          
     21          /*************************************************************************
     22          *                             野火嵌入式开发工作室
     23          *
     24          *  函数名称：uart_init
     25          *  功能说明：初始化串口，设置波特率
     26          *  参数说明：UARTn       模块号（UART0~UART5）
     27          *            baud        波特率，如9600、19200、56000、115200等
     28          *  函数返回：无
     29          *  修改时间：2012-1-20
     30          *  备    注：在官方例程上修改
     31          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     32          void uart_init (UARTn uratn, uint32 baud)
     33          {
   \                     uart_init:
   \   00000000   0xB4F0             PUSH     {R4-R7}
     34              register uint16 sbr, brfa;
     35              uint8 temp;
     36              uint32 sysclk;     //时钟
     37          
     38              /* 配置 UART功能的 GPIO 接口 开启时钟 */
     39              switch(uratn)
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD008             BEQ.N    ??uart_init_0
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD024             BEQ.N    ??uart_init_1
   \   0000000C   0xD314             BCC.N    ??uart_init_2
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD03F             BEQ.N    ??uart_init_3
   \   00000012   0xD32F             BCC.N    ??uart_init_4
   \   00000014   0x2805             CMP      R0,#+5
   \   00000016   0xD04B             BEQ.N    ??uart_init_5
   \   00000018   0xE059             B.N      ??uart_init_6
     40              {
     41              case UART0:
     42                  if(UART0_RX == PTA1)
     43                      PORTA_PCR1 = PORT_PCR_MUX(0x2);      //在PTA1上使能UART0_RXD
     44                  else if(UART0_RX == PTA15)
     45                      PORTA_PCR15 = PORT_PCR_MUX(0x3);     //在PTA15上使能UART0_RXD
     46                  else if(UART0_RX == PTB16)
     47                      PORTB_PCR16 = PORT_PCR_MUX(0x3);     //在PTB16上使能UART0_RXD
     48                  else if(UART0_RX == PTD6)
     49                      PORTD_PCR6 = PORT_PCR_MUX(0x3);      //在PTD6上使能UART0_RXD
   \                     ??uart_init_0:
   \   0000001A   0x....             LDR.N    R6,??DataTable7  ;; 0x4004c018
   \   0000001C   0xF44F 0x7740      MOV      R7,#+768
   \   00000020   0x6037             STR      R7,[R6, #+0]
     50          
     51                  if(UART0_TX == PTA2)
     52                      PORTA_PCR2 = PORT_PCR_MUX(0x2);     //在PTA2上使能UART0_RXD
     53                  else if(UART0_TX == PTA14)
     54                      PORTA_PCR14 = PORT_PCR_MUX(0x3);     //在PTA14上使能UART0_RXD
     55                  else if(UART0_TX == PTB17)
     56                      PORTB_PCR17 = PORT_PCR_MUX(0x3);     //在PTB17上使能UART0_RXD
     57                  else if(UART0_TX == PTD7)
     58                      PORTD_PCR7 = PORT_PCR_MUX(0x3);     //在PTD7上使能UART0_RXD
   \   00000022   0x....             LDR.N    R6,??DataTable7_1  ;; 0x4004c01c
   \   00000024   0xF44F 0x7740      MOV      R7,#+768
   \   00000028   0x6037             STR      R7,[R6, #+0]
     59          
     60                  SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;      //使能 UARTn 时钟
   \   0000002A   0x....             LDR.N    R6,??DataTable7_2  ;; 0x40048034
   \   0000002C   0x6836             LDR      R6,[R6, #+0]
   \   0000002E   0xF456 0x6680      ORRS     R6,R6,#0x400
   \   00000032   0x....             LDR.N    R7,??DataTable7_2  ;; 0x40048034
   \   00000034   0x603E             STR      R6,[R7, #+0]
     61                  break;
   \   00000036   0xE04A             B.N      ??uart_init_7
     62          
     63              case UART1:
     64                  if(UART1_RX == PTC3)
     65                      PORTC_PCR3 = PORT_PCR_MUX(0x3);     //在PTC3上使能UART1_RXD
   \                     ??uart_init_2:
   \   00000038   0x....             LDR.N    R6,??DataTable7_3  ;; 0x4004b00c
   \   0000003A   0xF44F 0x7740      MOV      R7,#+768
   \   0000003E   0x6037             STR      R7,[R6, #+0]
     66                  else if(UART1_RX == PTE1)
     67                      PORTE_PCR1 = PORT_PCR_MUX(0x3);     //在PTE1上使能UART1_RXD
     68                  
     69          
     70                  if(UART1_TX == PTC4)
     71                      PORTC_PCR4 = PORT_PCR_MUX(0x3);     //在PTC4上使能UART1_RXD
   \   00000040   0x....             LDR.N    R6,??DataTable7_4  ;; 0x4004b010
   \   00000042   0xF44F 0x7740      MOV      R7,#+768
   \   00000046   0x6037             STR      R7,[R6, #+0]
     72                  else if(UART1_TX == PTE0)
     73                      PORTE_PCR0 = PORT_PCR_MUX(0x3);     //在PTE0上使能UART1_RXD
     74                 
     75          
     76                  SIM_SCGC4 |= SIM_SCGC4_UART1_MASK;
   \   00000048   0x....             LDR.N    R6,??DataTable7_2  ;; 0x40048034
   \   0000004A   0x6836             LDR      R6,[R6, #+0]
   \   0000004C   0xF456 0x6600      ORRS     R6,R6,#0x800
   \   00000050   0x....             LDR.N    R7,??DataTable7_2  ;; 0x40048034
   \   00000052   0x603E             STR      R6,[R7, #+0]
     77                  break;
   \   00000054   0xE03B             B.N      ??uart_init_7
     78          
     79              case UART2:
     80                  PORTD_PCR3 = PORT_PCR_MUX(0x3);         //在PTD3上使能UART2_TXD功能
   \                     ??uart_init_1:
   \   00000056   0x....             LDR.N    R6,??DataTable7_5  ;; 0x4004c00c
   \   00000058   0xF44F 0x7740      MOV      R7,#+768
   \   0000005C   0x6037             STR      R7,[R6, #+0]
     81                  PORTD_PCR2 = PORT_PCR_MUX(0x3);         //在PTD2上使能UART2_RXD
   \   0000005E   0x....             LDR.N    R6,??DataTable7_6  ;; 0x4004c008
   \   00000060   0xF44F 0x7740      MOV      R7,#+768
   \   00000064   0x6037             STR      R7,[R6, #+0]
     82                  SIM_SCGC4 |= SIM_SCGC4_UART2_MASK;
   \   00000066   0x....             LDR.N    R6,??DataTable7_2  ;; 0x40048034
   \   00000068   0x6836             LDR      R6,[R6, #+0]
   \   0000006A   0xF456 0x5680      ORRS     R6,R6,#0x1000
   \   0000006E   0x....             LDR.N    R7,??DataTable7_2  ;; 0x40048034
   \   00000070   0x603E             STR      R6,[R7, #+0]
     83                  break;
   \   00000072   0xE02C             B.N      ??uart_init_7
     84          
     85              case UART3:
     86                  if(UART3_RX == PTB10)
     87                      PORTB_PCR10 = PORT_PCR_MUX(0x3);     //在PTB10上使能UART3_RXD
     88                  else if(UART3_RX == PTC16)
     89                      PORTC_PCR16 = PORT_PCR_MUX(0x3);     //在PTC16上使能UART3_RXD
   \                     ??uart_init_4:
   \   00000074   0x....             LDR.N    R6,??DataTable7_7  ;; 0x4004b040
   \   00000076   0xF44F 0x7740      MOV      R7,#+768
   \   0000007A   0x6037             STR      R7,[R6, #+0]
     90                  else if(UART3_RX == PTE5)
     91                      PORTE_PCR5 = PORT_PCR_MUX(0x3);      //在PTE5上使能UART3_RXD
     92                          
     93          
     94                  if(UART3_TX == PTB11)
     95                      PORTB_PCR11 = PORT_PCR_MUX(0x3);     //在PTB11上使能UART3_RXD
     96                  else if(UART3_TX == PTC17)
     97                      PORTC_PCR17 = PORT_PCR_MUX(0x3);     //在PTC17上使能UART3_RXD
   \   0000007C   0x....             LDR.N    R6,??DataTable7_8  ;; 0x4004b044
   \   0000007E   0xF44F 0x7740      MOV      R7,#+768
   \   00000082   0x6037             STR      R7,[R6, #+0]
     98                  else if(UART3_TX == PTE4)
     99                      PORTE_PCR4 = PORT_PCR_MUX(0x3);     //在PTE4上使能UART3_RXD
    100               
    101                  SIM_SCGC4 |= SIM_SCGC4_UART3_MASK;
   \   00000084   0x....             LDR.N    R6,??DataTable7_2  ;; 0x40048034
   \   00000086   0x6836             LDR      R6,[R6, #+0]
   \   00000088   0xF456 0x5600      ORRS     R6,R6,#0x2000
   \   0000008C   0x....             LDR.N    R7,??DataTable7_2  ;; 0x40048034
   \   0000008E   0x603E             STR      R6,[R7, #+0]
    102                  break;
   \   00000090   0xE01D             B.N      ??uart_init_7
    103          
    104              case UART4:
    105                  if(UART4_RX == PTC14)
    106                      PORTC_PCR14 = PORT_PCR_MUX(0x3);     //在PTC14上使能UART4_RXD
    107                  else if(UART4_RX == PTE25)
    108                      PORTE_PCR25 = PORT_PCR_MUX(0x3);     //在PTE25上使能UART4_RXD
   \                     ??uart_init_3:
   \   00000092   0x....             LDR.N    R6,??DataTable7_9  ;; 0x4004d064
   \   00000094   0xF44F 0x7740      MOV      R7,#+768
   \   00000098   0x6037             STR      R7,[R6, #+0]
    109                 
    110                  if(UART4_TX == PTC15)
    111                      PORTC_PCR15 = PORT_PCR_MUX(0x3);     //在PTC15上使能UART4_RXD
    112                  else if(UART4_TX == PTE24)
    113                      PORTE_PCR24 = PORT_PCR_MUX(0x3);     //在PTE24上使能UART4_RXD
   \   0000009A   0x....             LDR.N    R6,??DataTable7_10  ;; 0x4004d060
   \   0000009C   0xF44F 0x7740      MOV      R7,#+768
   \   000000A0   0x6037             STR      R7,[R6, #+0]
    114                               //设置管脚有误？
    115          
    116                  SIM_SCGC1 |= SIM_SCGC1_UART4_MASK;
   \   000000A2   0x....             LDR.N    R6,??DataTable7_11  ;; 0x40048028
   \   000000A4   0x6836             LDR      R6,[R6, #+0]
   \   000000A6   0xF456 0x6680      ORRS     R6,R6,#0x400
   \   000000AA   0x....             LDR.N    R7,??DataTable7_11  ;; 0x40048028
   \   000000AC   0x603E             STR      R6,[R7, #+0]
    117                  break;
   \   000000AE   0xE00E             B.N      ??uart_init_7
    118          
    119              case UART5:
    120                  if(UART5_RX == PTD8)
    121                      PORTD_PCR8 = PORT_PCR_MUX(0x3);     //在PTD8上使能UART5_RXD
    122                  else if(UART5_RX == PTE9)
    123                      PORTE_PCR9 = PORT_PCR_MUX(0x3);     //在PTE9上使能UART5_RXD
   \                     ??uart_init_5:
   \   000000B0   0x....             LDR.N    R6,??DataTable7_12  ;; 0x4004d024
   \   000000B2   0xF44F 0x7740      MOV      R7,#+768
   \   000000B6   0x6037             STR      R7,[R6, #+0]
    124                  
    125                  if(UART5_TX == PTD9)
    126                      PORTD_PCR9 = PORT_PCR_MUX(0x3);     //在PTD9上使能UART5_RXD
    127                  else if(UART5_TX == PTE8)
    128                      PORTE_PCR8 = PORT_PCR_MUX(0x3);     //在PTE8上使能UART5_RXD
   \   000000B8   0x....             LDR.N    R6,??DataTable7_13  ;; 0x4004d020
   \   000000BA   0xF44F 0x7740      MOV      R7,#+768
   \   000000BE   0x6037             STR      R7,[R6, #+0]
    129                  
    130                  SIM_SCGC1 |= SIM_SCGC1_UART5_MASK;
   \   000000C0   0x....             LDR.N    R6,??DataTable7_11  ;; 0x40048028
   \   000000C2   0x6836             LDR      R6,[R6, #+0]
   \   000000C4   0xF456 0x6600      ORRS     R6,R6,#0x800
   \   000000C8   0x....             LDR.N    R7,??DataTable7_11  ;; 0x40048028
   \   000000CA   0x603E             STR      R6,[R7, #+0]
    131                  break;
   \   000000CC   0xE7FF             B.N      ??uart_init_7
    132              default:
    133                  break;
    134              }
    135          
    136          
    137              //设置的时候，应该禁止发送接受
    138              UART_C2_REG(UARTx[uratn]) &= ~(UART_C2_TE_MASK  | UART_C2_RE_MASK );
   \                     ??uart_init_6:
   \                     ??uart_init_7:
   \   000000CE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D0   0x....             LDR.N    R6,??DataTable7_14
   \   000000D2   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   000000D6   0x78F6             LDRB     R6,[R6, #+3]
   \   000000D8   0xF016 0x06F3      ANDS     R6,R6,#0xF3
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0x....             LDR.N    R7,??DataTable7_14
   \   000000E0   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
   \   000000E4   0x70FE             STRB     R6,[R7, #+3]
    139          
    140              //配置成8位无校验模式
    141              //设置 UART 数据格式、校验方式和停止位位数。通过设置 UART 模块控制寄存器 C1 实现；
    142              UART_C1_REG(UARTx[uratn]) = 0;	// 全部直接使用默认设置就行，所以直接清0
   \   000000E6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E8   0x....             LDR.N    R6,??DataTable7_14
   \   000000EA   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   000000EE   0x2700             MOVS     R7,#+0
   \   000000F0   0x70B7             STRB     R7,[R6, #+2]
    143          
    144              //计算波特率，串口0、1使用内核时钟，其它串口使用外设时钟
    145              if ((uratn == UART0) | (uratn == UART1))
   \   000000F2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD101             BNE.N    ??uart_init_8
   \   000000F8   0x2601             MOVS     R6,#+1
   \   000000FA   0xE000             B.N      ??uart_init_9
   \                     ??uart_init_8:
   \   000000FC   0x2600             MOVS     R6,#+0
   \                     ??uart_init_9:
   \   000000FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000100   0x2801             CMP      R0,#+1
   \   00000102   0xD101             BNE.N    ??uart_init_10
   \   00000104   0x2701             MOVS     R7,#+1
   \   00000106   0xE000             B.N      ??uart_init_11
   \                     ??uart_init_10:
   \   00000108   0x2700             MOVS     R7,#+0
   \                     ??uart_init_11:
   \   0000010A   0x433E             ORRS     R6,R7,R6
   \   0000010C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000010E   0x2E00             CMP      R6,#+0
   \   00000110   0xD002             BEQ.N    ??uart_init_12
    146                  sysclk = core_clk_khz * 1000;            //内核时钟
   \   00000112   0x....             LDR.N    R6,??DataTable7_15  ;; 0xaba9500
   \   00000114   0x0035             MOVS     R5,R6
   \   00000116   0xE001             B.N      ??uart_init_13
    147              else
    148                  sysclk = bus_clk_khz * 1000;  //外设时钟
   \                     ??uart_init_12:
   \   00000118   0x....             LDR.N    R6,??DataTable7_16  ;; 0x55d4a80
   \   0000011A   0x0035             MOVS     R5,R6
    149          
    150              //设置 UART 数据通讯波特率。通过设置 UART 模块的波特率寄存器
    151              sbr = (uint16)(sysclk / (baud << 4));
   \                     ??uart_init_13:
   \   0000011C   0x010E             LSLS     R6,R1,#+4
   \   0000011E   0xFBB5 0xF6F6      UDIV     R6,R5,R6
   \   00000122   0x0032             MOVS     R2,R6
    152          
    153              /* Save off the current value of the UARTx_BDH except for the SBR field */
    154              temp = UART_BDH_REG(UARTx[uratn]) & ~(UART_BDH_SBR(0x1F));
   \   00000124   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000126   0x....             LDR.N    R6,??DataTable7_14
   \   00000128   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   0000012C   0x7836             LDRB     R6,[R6, #+0]
   \   0000012E   0xF016 0x06E0      ANDS     R6,R6,#0xE0
   \   00000132   0x0034             MOVS     R4,R6
    155          
    156              UART_BDH_REG(UARTx[uratn]) = temp |  UART_BDH_SBR(((sbr & 0x1F00) >> 8));
   \   00000134   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000136   0x0A16             LSRS     R6,R2,#+8
   \   00000138   0xF016 0x061F      ANDS     R6,R6,#0x1F
   \   0000013C   0x4326             ORRS     R6,R6,R4
   \   0000013E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000140   0x....             LDR.N    R7,??DataTable7_14
   \   00000142   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
   \   00000146   0x703E             STRB     R6,[R7, #+0]
    157              UART_BDL_REG(UARTx[uratn]) = (uint8)(sbr & UART_BDL_SBR_MASK);
   \   00000148   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014A   0x....             LDR.N    R6,??DataTable7_14
   \   0000014C   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   00000150   0x7072             STRB     R2,[R6, #+1]
    158          
    159              //brfa = (((sysclk*32)/(baud * 16)) - (sbr * 32));
    160              brfa = (((sysclk << 5) / (baud << 4)) - (sbr << 5));
   \   00000152   0x016E             LSLS     R6,R5,#+5
   \   00000154   0x010F             LSLS     R7,R1,#+4
   \   00000156   0xFBB6 0xF6F7      UDIV     R6,R6,R7
   \   0000015A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000015C   0xEBB6 0x1642      SUBS     R6,R6,R2, LSL #+5
   \   00000160   0x0033             MOVS     R3,R6
    161          
    162              /* Save off the current value of the UARTx_C4 register except for the BRFA field */
    163              temp = UART_C4_REG(UARTx[uratn]) & ~(UART_C4_BRFA(0x1F));
   \   00000162   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000164   0x....             LDR.N    R6,??DataTable7_14
   \   00000166   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   0000016A   0x7AB6             LDRB     R6,[R6, #+10]
   \   0000016C   0xF016 0x06E0      ANDS     R6,R6,#0xE0
   \   00000170   0x0034             MOVS     R4,R6
    164          
    165              UART_C4_REG(UARTx[uratn]) = temp |  UART_C4_BRFA(brfa);
   \   00000172   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000174   0x....             LDR.N    R6,??DataTable7_14
   \   00000176   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   0000017A   0xF013 0x071F      ANDS     R7,R3,#0x1F
   \   0000017E   0x4327             ORRS     R7,R7,R4
   \   00000180   0x72B7             STRB     R7,[R6, #+10]
    166          
    167              /* 允许发送和接收 */
    168              UART_C2_REG(UARTx[uratn]) |= (UART_C2_TE_MASK | UART_C2_RE_MASK );
   \   00000182   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000184   0x....             LDR.N    R6,??DataTable7_14
   \   00000186   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   0000018A   0x78F6             LDRB     R6,[R6, #+3]
   \   0000018C   0xF056 0x060C      ORRS     R6,R6,#0xC
   \   00000190   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000192   0x....             LDR.N    R7,??DataTable7_14
   \   00000194   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
   \   00000198   0x70FE             STRB     R6,[R7, #+3]
    169          
    170              //设置是否允许接收和发送中断。通过设置 UART 模块的 C2 寄存器的
    171              //RIE 和 TIE 位实现。如果使能中断，必须首先实现中断服务程序；
    172          }
   \   0000019A   0xBCF0             POP      {R4-R7}
   \   0000019C   0x4770             BX       LR               ;; return
    173          
    174          /*************************************************************************
    175          *                             野火嵌入式开发工作室
    176          *
    177          *  函数名称：uart_getchar
    178          *  功能说明：无限时间等待串口接受一个字节
    179          *  参数说明：UARTn       模块号（UART0~UART5）
    180          *  函数返回：接收到的字节
    181          *  修改时间：2012-1-20
    182          *  备    注：官方例程
    183          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    184          char uart_getchar (UARTn uratn)
    185          {
    186              /* Wait until character has been received */
    187              while (!(UART_S1_REG(UARTx[uratn]) & UART_S1_RDRF_MASK));
   \                     uart_getchar:
   \                     ??uart_getchar_0:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R1,??DataTable7_14
   \   00000004   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000008   0x7909             LDRB     R1,[R1, #+4]
   \   0000000A   0x0689             LSLS     R1,R1,#+26
   \   0000000C   0xD5F8             BPL.N    ??uart_getchar_0
    188          
    189              /* Return the 8-bit data from the receiver */
    190              return UART_D_REG(UARTx[uratn]);
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x....             LDR.N    R1,??DataTable7_14
   \   00000012   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000016   0x79C0             LDRB     R0,[R0, #+7]
   \   00000018   0x4770             BX       LR               ;; return
    191          }
    192          
    193          /*************************************************************************
    194          *                             野火嵌入式开发工作室
    195          *
    196          *  函数名称：uart_pendchar
    197          *  功能说明：有限时间等待串口接受一个字节
    198          *  参数说明：UARTn       模块号（UART0~UART5）
    199          *  函数返回：接收到的字节
    200          *  修改时间：2012-1-20
    201          *  备    注：
    202          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    203          char uart_pendchar (UARTn uratn, char *ch)
    204          {
   \                     uart_pendchar:
   \   00000000   0x0002             MOVS     R2,R0
    205              uint32 i = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    206          
    207              while(++i < 0xffffff)                                         //时间限制
   \                     ??uart_pendchar_0:
   \   00000004   0x1C5B             ADDS     R3,R3,#+1
   \   00000006   0xF07F 0x407F      MVNS     R0,#-16777216
   \   0000000A   0x4283             CMP      R3,R0
   \   0000000C   0xD20E             BCS.N    ??uart_pendchar_1
    208              {
    209                  if(UART_S1_REG(UARTx[uratn]) & UART_S1_RDRF_MASK)         //查询是否接受到数据
   \   0000000E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000010   0x....             LDR.N    R0,??DataTable7_14
   \   00000012   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \   00000016   0x7900             LDRB     R0,[R0, #+4]
   \   00000018   0x0680             LSLS     R0,R0,#+26
   \   0000001A   0xD5F3             BPL.N    ??uart_pendchar_0
    210                  {
    211                      *ch  =   UART_D_REG(UARTx[uratn]);                    //接受到8位的数据
   \   0000001C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001E   0x....             LDR.N    R0,??DataTable7_14
   \   00000020   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \   00000024   0x79C0             LDRB     R0,[R0, #+7]
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    212                      return  1;                                            //返回 1 表示接收成功
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE002             B.N      ??uart_pendchar_2
    213                  }
    214              }
    215          
    216              *ch = 0;                                                     //接收不到，应该清空了接收区
   \                     ??uart_pendchar_1:
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    217              return 0;                                                    //返回0表示接收失败
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??uart_pendchar_2:
   \   00000032   0x4770             BX       LR               ;; return
    218          }
    219          
    220          /*************************************************************************
    221          *  函数名称：uart_pendchar
    222          *  功能说明：有限时间等待串口接受一个字节
    223          *  参数说明：UARTn       模块号（UART0~UART5）
    224          *  函数返回：接收到的字节
    225          *  修改时间：2012-1-20
    226          *  备    注：
    227          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    228          char uart_pendchar1 (UARTn uratn)
    229          {
    230             
    231              
    232                
    233                      return UART_D_REG(UARTx[uratn]);                    //接受到8位的数据 
   \                     uart_pendchar1:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R1,??DataTable7_14
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0x79C0             LDRB     R0,[R0, #+7]
   \   0000000A   0x4770             BX       LR               ;; return
    234                     
    235                                                                                     
    236          }
    237          
    238          
    239          /*************************************************************************
    240          *                             野火嵌入式开发工作室
    241          *
    242          *  函数名称：uart_pendstr
    243          *  功能说明：有限时间等待串口接受字符串
    244          *  参数说明：UARTn       模块号（UART0~UART5）
    245          *  函数返回：接收到的字节
    246          *  修改时间：2012-1-20
    247          *  备    注：
    248          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    249          char uart_pendstr (UARTn uratn, char *str)
    250          {
   \                     uart_pendstr:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    251              uint32 i = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    252              while(uart_pendchar(uratn, str + i++));
   \                     ??uart_pendstr_0:
   \   00000008   0x1971             ADDS     R1,R6,R5
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       uart_pendchar
   \   00000012   0x1C76             ADDS     R6,R6,#+1
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD1F6             BNE.N    ??uart_pendstr_0
    253          
    254              return (i <= 1 ? 0 : 1);
   \   0000001A   0x2E02             CMP      R6,#+2
   \   0000001C   0xD201             BCS.N    ??uart_pendstr_1
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE000             B.N      ??uart_pendstr_2
   \                     ??uart_pendstr_1:
   \   00000022   0x2001             MOVS     R0,#+1
   \                     ??uart_pendstr_2:
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
    255          }
    256          
    257          
    258          
    259          /*************************************************************************
    260          *                             野火嵌入式开发工作室
    261          *
    262          *  函数名称：uart_putchar
    263          *  功能说明：串口发送一个字节
    264          *  参数说明：UARTn       模块号（UART0~UART5）
    265          *  函数返回：无
    266          *  修改时间：2012-1-20
    267          *  备    注：官方例程，printf会调用这函数
    268          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    269          void uart_putchar (UARTn uratn, char ch)
    270          {
    271              //等待发送缓冲区空
    272              while(!(UART_S1_REG(UARTx[uratn]) & UART_S1_TDRE_MASK));
   \                     uart_putchar:
   \                     ??uart_putchar_0:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R2,??DataTable7_14
   \   00000004   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000008   0x7912             LDRB     R2,[R2, #+4]
   \   0000000A   0x0612             LSLS     R2,R2,#+24
   \   0000000C   0xD5F8             BPL.N    ??uart_putchar_0
    273              //发送数据
    274              UART_D_REG(UARTx[uratn]) = (uint8)ch;
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x....             LDR.N    R2,??DataTable7_14
   \   00000012   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000016   0x71D1             STRB     R1,[R2, #+7]
    275          }
   \   00000018   0x4770             BX       LR               ;; return
    276          
    277          
    278          
    279          /*************************************************************************
    280          *                             野火嵌入式开发工作室
    281          *
    282          *  函数名称：uart_query
    283          *  功能说明：查询是否接受到一个字节
    284          *  参数说明：UARTn       模块号（UART0~UART5）
    285          *  函数返回：1           接收到一个字节了
    286          *            0           没有接收到
    287          *  修改时间：2012-1-20
    288          *  备    注：官方例程
    289          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    290          int uart_query (UARTn uratn)
    291          {
    292              return (UART_S1_REG(UARTx[uratn]) & UART_S1_RDRF_MASK);
   \                     uart_query:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R1,??DataTable7_14
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0x7900             LDRB     R0,[R0, #+4]
   \   0000000A   0xF010 0x0020      ANDS     R0,R0,#0x20
   \   0000000E   0x4770             BX       LR               ;; return
    293          }
    294          
    295          /*************************************************************************
    296          *                             野火嵌入式开发工作室
    297          *
    298          *  函数名称：uart_sendN
    299          *  功能说明：串行 发送指定len个字节长度字符串 （包括 NULL 也会发送）
    300          *  参数说明：UARTn       模块号（UART0~UART5）
    301          *            buff        发送缓冲区
    302          *            len         发送长度
    303          *  函数返回：无
    304          *  修改时间：2012-1-20
    305          *  备    注：
    306          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    307          void uart_sendN (UARTn uratn, uint8 *buff, uint16 len)
    308          {
   \                     uart_sendN:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    309              int i;
    310              for(i = 0; i < len; i++)
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0007             MOVS     R7,R0
   \                     ??uart_sendN_0:
   \   0000000C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000E   0x42B7             CMP      R7,R6
   \   00000010   0xDA06             BGE.N    ??uart_sendN_1
    311              {
    312                  uart_putchar(uratn, buff[i]);
   \   00000012   0x5D79             LDRB     R1,[R7, R5]
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       uart_putchar
    313              }
   \   0000001C   0x1C7F             ADDS     R7,R7,#+1
   \   0000001E   0xE7F5             B.N      ??uart_sendN_0
    314          }
   \                     ??uart_sendN_1:
   \   00000020   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    315          
    316          /*************************************************************************
    317          *                             野火嵌入式开发工作室
    318          *
    319          *  函数名称：uart_sendStr
    320          *  功能说明：串行发送字符串
    321          *  参数说明：UARTn       模块号（UART0~UART5）
    322          *            str         字符串
    323          *  函数返回：无
    324          *  修改时间：2012-1-20
    325          *  备    注：
    326          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    327          void uart_sendStr (UARTn uratn, const uint8 *str)
    328          {
   \                     uart_sendStr:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    329              while(*str)
   \                     ??uart_sendStr_0:
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??uart_sendStr_1
    330              {
    331                  uart_putchar(uratn, *str++);
   \   0000000C   0x7829             LDRB     R1,[R5, #+0]
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       uart_putchar
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \   00000018   0xE7F5             B.N      ??uart_sendStr_0
    332              }
    333          }
   \                     ??uart_sendStr_1:
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    334          
    335          /*************************************************************************
    336          *                             野火嵌入式开发工作室
    337          *
    338          *  函数名称：uart_irq_EN
    339          *  功能说明：开串口接收中断
    340          *  参数说明：UARTn       模块号（UART0~UART5）
    341          *  函数返回：无
    342          *  修改时间：2012-1-20
    343          *  备    注：
    344          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    345          void uart_irq_EN(UARTn uratn)
    346          {
   \                     uart_irq_EN:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    347              UART_C2_REG(UARTx[uratn]) |= UART_C2_RIE_MASK;    //开放UART接收中断
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x....             LDR.N    R0,??DataTable7_14
   \   00000008   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000000C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000000E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x....             LDR.N    R1,??DataTable7_14
   \   00000016   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000001A   0x70C8             STRB     R0,[R1, #+3]
    348              enable_irq((uratn << 1) + 45);			        //开接收引脚的IRQ中断
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x0060             LSLS     R0,R4,#+1
   \   00000020   0x302D             ADDS     R0,R0,#+45
   \   00000022   0x.... 0x....      BL       enable_irq
    349          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    350          
    351          
    352          /*************************************************************************
    353          *                             野火嵌入式开发工作室
    354          *
    355          *  函数名称：uart_irq_DIS
    356          *  功能说明：关串口接收中断
    357          *  参数说明：UARTn       模块号（UART0~UART5）
    358          *  函数返回：无
    359          *  修改时间：2012-1-20
    360          *  备    注：
    361          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    362          void uart_irq_DIS(UARTn uratn)
    363          {
   \                     uart_irq_DIS:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    364              UART_C2_REG(UARTx[uratn]) &= ~UART_C2_RIE_MASK;   //禁止UART接收中断
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x....             LDR.N    R0,??DataTable7_14
   \   00000008   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000000C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000000E   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x....             LDR.N    R1,??DataTable7_14
   \   00000016   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000001A   0x70C8             STRB     R0,[R1, #+3]
    365              disable_irq((uratn << 1) + 45);			        //关接收引脚的IRQ中断
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x0060             LSLS     R0,R4,#+1
   \   00000020   0x302D             ADDS     R0,R0,#+45
   \   00000022   0x.... 0x....      BL       disable_irq
    366          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x4004C018         DC32     0x4004c018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x4004C01C         DC32     0x4004c01c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x4004B00C         DC32     0x4004b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x4004B010         DC32     0x4004b010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x4004C00C         DC32     0x4004c00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x4004C008         DC32     0x4004c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x4004B040         DC32     0x4004b040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x4004B044         DC32     0x4004b044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x4004D064         DC32     0x4004d064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x4004D060         DC32     0x4004d060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x40048028         DC32     0x40048028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x4004D024         DC32     0x4004d024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x4004D020         DC32     0x4004d020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_14:
   \   00000000   0x........         DC32     UARTx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_15:
   \   00000000   0x0ABA9500         DC32     0xaba9500

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_16:
   \   00000000   0x055D4A80         DC32     0x55d4a80
    367          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  uart_getchar
       16  uart_init
        8  uart_irq_DIS
              8 -> disable_irq
        8  uart_irq_EN
              8 -> enable_irq
        0  uart_pendchar
        0  uart_pendchar1
       16  uart_pendstr
             16 -> uart_pendchar
        0  uart_putchar
        0  uart_query
       24  uart_sendN
             24 -> uart_putchar
       16  uart_sendStr
             16 -> uart_putchar


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_16
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
      24  UARTx
      26  uart_getchar
     414  uart_init
      40  uart_irq_DIS
      40  uart_irq_EN
      52  uart_pendchar
      12  uart_pendchar1
      40  uart_pendstr
      26  uart_putchar
      16  uart_query
      34  uart_sendN
      28  uart_sendStr

 
  24 bytes in section .data
 796 bytes in section .text
 
 796 bytes of CODE memory
  24 bytes of DATA memory

Errors: none
Warnings: none
