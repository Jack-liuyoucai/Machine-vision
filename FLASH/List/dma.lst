###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        24/Jun/2014  19:43:55
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\Drivers\dma\dma.c
#    Command line =  
#        "D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\Drivers\dma\dma.c" -D
#        IAR -D TWR_K60N512 -D DEBUG -lCN "D:\第九届飞思卡尔\备份\0623
#        -新板子\FLASH\List\" -lB "D:\第九届飞思卡尔\备份\0623
#        -新板子\FLASH\List\" -o "D:\第九届飞思卡尔\备份\0623
#        -新板子\FLASH\Obj\" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        D:\dowload\iark60\arm\INC\c\DLib_Config_Normal.h -I
#        "D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\Cpu\" -I
#        "D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\App\" -I
#        "D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\Drivers\adc\" -I
#        "D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\Drivers\delay\" -I
#        "D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\Drivers\FTM\" -I
#        "D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\Drivers\gpio\" -I
#        "D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\Drivers\lptmr\" -I
#        "D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\Drivers\mcg\" -I
#        "D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\Drivers\PIT\" -I
#        "D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\Drivers\uart\" -I
#        "D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\Drivers\oled\" -I
#        "D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\Drivers\spi\" -On
#        --use_c++_inline
#    List file    =  D:\第九届飞思卡尔\备份\0623 -新板子\FLASH\List\dma.lst
#    Object file  =  D:\第九届飞思卡尔\备份\0623 -新板子\FLASH\Obj\dma.o
#
###############################################################################

D:\第九届飞思卡尔\备份\0623 -新板子\src\Sources\Drivers\dma\dma.c
      1          #include "include.h"
      2          
      3          //u8 counttempaddr;
      4          #define COUNTSADDR   0x4004000C  //(&counttempaddr)
      5          #define COUNTDADDR   0x4004000C  //(&counttempaddr)
      6          

   \                                 In section .bss, align 4
      7          uint32 count_init[16];         //用来保存16个通道的初始化计数值
   \                     count_init:
   \   00000000                      DS8 64
      8          
      9           ////////////////////////////////////////////////////////
     10          
     11           ////////////////////////////
     12          /*************************************************************************
     13          *                             野火嵌入式开发工作室
     14          *
     15          *  函数名称：DMA_PORTx2BUFF_Init
     16          *  功能说明：DMA初始化，读取端口数据到内存
     17          *  参数说明：DMA_CHn              通道号（DMA_CH0 ~ DMA_CH15）
     18          *            SADDR                源地址( (void * )&PTx_BYTEn_IN 或 (void * )&PTx_WORDn_IN   )
     19          *            DADDR                目的地址
     20          *            PTxn                 触发端口
     21          *            DMA_BYTEn            每次DMA传输字节数
     22          *            count                一个主循环传输字节数
     23          *            DMA_PORTx2BUFF_cfg   DMA传输配置
     24          *  函数返回：无
     25          *  修改时间：2012-2-20
     26          *  备    注：
     27          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     28          void DMA_PORTx2BUFF_Init(DMA_CHn CHn, void *SADDR, void *DADDR, PTxn ptxn, DMA_BYTEn byten, uint32 count, DMA_PORTx2BUFF_cfg cfg)
     29          {
   \                     DMA_PORTx2BUFF_Init: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x980A             LDR      R0,[SP, #+40]
   \   00000008   0x9E0B             LDR      R6,[SP, #+44]
   \   0000000A   0x9C0C             LDR      R4,[SP, #+48]
     30              uint8 n, i, tmp;
     31              
     32              uint8 BYTEs = (byten == DMA_BYTE1 ? 1 : (byten == DMA_BYTE2 ? 2 : (byten == DMA_BYTE4 ? 4 : 16 ) ) ); //计算传输字节数
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD102             BNE.N    ??DMA_PORTx2BUFF_Init_0
   \   00000012   0xF05F 0x0801      MOVS     R8,#+1
   \   00000016   0xE00D             B.N      ??DMA_PORTx2BUFF_Init_1
   \                     ??DMA_PORTx2BUFF_Init_0: (+1)
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD102             BNE.N    ??DMA_PORTx2BUFF_Init_2
   \   0000001E   0xF05F 0x0802      MOVS     R8,#+2
   \   00000022   0xE007             B.N      ??DMA_PORTx2BUFF_Init_3
   \                     ??DMA_PORTx2BUFF_Init_2: (+1)
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD102             BNE.N    ??DMA_PORTx2BUFF_Init_4
   \   0000002A   0xF05F 0x0804      MOVS     R8,#+4
   \   0000002E   0xE001             B.N      ??DMA_PORTx2BUFF_Init_3
   \                     ??DMA_PORTx2BUFF_Init_4: (+1)
   \   00000030   0xF05F 0x0810      MOVS     R8,#+16
     33          
     34              /* 开启时钟 */
     35              SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;                        //打开DMA模块时钟
   \                     ??DMA_PORTx2BUFF_Init_3: (+1)
   \                     ??DMA_PORTx2BUFF_Init_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R9,??DataTable3  ;; 0x40048040
   \   00000038   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \   0000003C   0xF059 0x0902      ORRS     R9,R9,#0x2
   \   00000040   0x.... 0x....      LDR.W    R10,??DataTable3  ;; 0x40048040
   \   00000044   0xF8CA 0x9000      STR      R9,[R10, #+0]
     36              SIM_SCGC6 |= SIM_SCGC6_DMAMUX_MASK;                     //打开DMA多路复用器时钟
   \   00000048   0x.... 0x....      LDR.W    R9,??DataTable3_1  ;; 0x4004803c
   \   0000004C   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \   00000050   0xF059 0x0902      ORRS     R9,R9,#0x2
   \   00000054   0x.... 0x....      LDR.W    R10,??DataTable3_1  ;; 0x4004803c
   \   00000058   0xF8CA 0x9000      STR      R9,[R10, #+0]
     37          
     38              /* 配置 DMA 通道 的 传输控制块 TCD ( Transfer Control Descriptor ) */
     39              DMA_SADDR(CHn) =    (uint32)SADDR;                         // 设置  源地址
   \   0000005C   0x.... 0x....      LDR.W    R9,??DataTable3_2  ;; 0x40009000
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0xEA5F 0x1A45      LSLS     R10,R5,#+5
   \   00000066   0xF84A 0x1009      STR      R1,[R10, R9]
     40              DMA_DADDR(CHn) =    (uint32)DADDR;                         // 设置目的地址
   \   0000006A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006C   0xEA5F 0x1945      LSLS     R9,R5,#+5
   \   00000070   0xF109 0x4980      ADD      R9,R9,#+1073741824
   \   00000074   0xF519 0x4910      ADDS     R9,R9,#+36864
   \   00000078   0xF8C9 0x2010      STR      R2,[R9, #+16]
     41              DMA_SOFF(CHn)  =    0x00u;                              // 设置源地址偏移 = 0x0, 即不变
   \   0000007C   0xF05F 0x0900      MOVS     R9,#+0
   \   00000080   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000082   0xEA5F 0x1A45      LSLS     R10,R5,#+5
   \   00000086   0xF10A 0x4A80      ADD      R10,R10,#+1073741824
   \   0000008A   0xF51A 0x4A10      ADDS     R10,R10,#+36864
   \   0000008E   0xF8AA 0x9004      STRH     R9,[R10, #+4]
     42              DMA_DOFF(CHn)  =    BYTEs;                              // 每次传输后，目的地址加 BYTEs
   \   00000092   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000096   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000098   0xEA5F 0x1945      LSLS     R9,R5,#+5
   \   0000009C   0xF109 0x4980      ADD      R9,R9,#+1073741824
   \   000000A0   0xF519 0x4910      ADDS     R9,R9,#+36864
   \   000000A4   0xF8A9 0x8014      STRH     R8,[R9, #+20]
     43          
     44              DMA_ATTR(CHn)  =    (0
     45                                   | DMA_ATTR_SMOD(0x0)                // 源地址模数禁止  Source address modulo feature is disabled
     46                                   | DMA_ATTR_SSIZE(byten)             // 源数据位宽 ：DMA_BYTEn  。    SSIZE = 0 -> 8-bit ，SSIZE = 1 -> 16-bit ，SSIZE = 2 -> 32-bit ，SSIZE = 4 -> 16-byte
     47                                   | DMA_ATTR_DMOD(0x0)                // 目标地址模数禁止
     48                                   | DMA_ATTR_DSIZE(byten)             // 目标数据位宽 ：DMA_BYTEn  。  设置参考  SSIZE
     49                                  );
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0xEA5F 0x2900      LSLS     R9,R0,#+8
   \   000000AE   0xF419 0x69E0      ANDS     R9,R9,#0x700
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0xF010 0x0A07      ANDS     R10,R0,#0x7
   \   000000B8   0xEA5A 0x0909      ORRS     R9,R10,R9
   \   000000BC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BE   0xEA5F 0x1A45      LSLS     R10,R5,#+5
   \   000000C2   0xF10A 0x4A80      ADD      R10,R10,#+1073741824
   \   000000C6   0xF51A 0x4A10      ADDS     R10,R10,#+36864
   \   000000CA   0xF8AA 0x9006      STRH     R9,[R10, #+6]
     50          
     51              DMA_CITER_ELINKNO(CHn)  = DMA_CITER_ELINKNO_CITER(count); //当前主循环次数
   \   000000CE   0x46B1             MOV      R9,R6
   \   000000D0   0xEA5F 0x4949      LSLS     R9,R9,#+17       ;; ZeroExtS R9,R9,#+17,#+17
   \   000000D4   0xEA5F 0x4959      LSRS     R9,R9,#+17
   \   000000D8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000DA   0xEA5F 0x1A45      LSLS     R10,R5,#+5
   \   000000DE   0xF10A 0x4A80      ADD      R10,R10,#+1073741824
   \   000000E2   0xF51A 0x4A10      ADDS     R10,R10,#+36864
   \   000000E6   0xF8AA 0x9016      STRH     R9,[R10, #+22]
     52              DMA_BITER_ELINKNO(CHn)  = DMA_BITER_ELINKYES_BITER(count);//起始主循环次数
   \   000000EA   0x46B1             MOV      R9,R6
   \   000000EC   0xEA5F 0x59C9      LSLS     R9,R9,#+23       ;; ZeroExtS R9,R9,#+23,#+23
   \   000000F0   0xEA5F 0x59D9      LSRS     R9,R9,#+23
   \   000000F4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F6   0xEA5F 0x1A45      LSLS     R10,R5,#+5
   \   000000FA   0xF10A 0x4A80      ADD      R10,R10,#+1073741824
   \   000000FE   0xF51A 0x4A10      ADDS     R10,R10,#+36864
   \   00000102   0xF8AA 0x901E      STRH     R9,[R10, #+30]
     53          
     54          
     55              DMA_CR &= ~DMA_CR_EMLM_MASK;                            // CR[EMLM] = 0
   \   00000106   0x.... 0x....      LDR.W    R9,??DataTable3_3  ;; 0x40008000
   \   0000010A   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \   0000010E   0xF039 0x0980      BICS     R9,R9,#0x80
   \   00000112   0x.... 0x....      LDR.W    R10,??DataTable3_3  ;; 0x40008000
   \   00000116   0xF8CA 0x9000      STR      R9,[R10, #+0]
     56          
     57              //当CR[EMLM] = 0 时:
     58              DMA_NBYTES_MLNO(CHn) =   DMA_NBYTES_MLNO_NBYTES(BYTEs); // 通道每次传输字节数，这里设置为BYTEs个字节。注：值为0表示传输4GB */
   \   0000011A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000011E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000120   0xEA5F 0x1945      LSLS     R9,R5,#+5
   \   00000124   0xF109 0x4980      ADD      R9,R9,#+1073741824
   \   00000128   0xF519 0x4910      ADDS     R9,R9,#+36864
   \   0000012C   0xF8C9 0x8008      STR      R8,[R9, #+8]
     59          
     60          
     61              /* 配置 DMA 传输结束后的操作 */
     62              DMA_SLAST(CHn)      =   0;                              //调整  源地址的附加值,主循环结束后恢复  源地址
   \   00000130   0xF05F 0x0900      MOVS     R9,#+0
   \   00000134   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000136   0xEA5F 0x1A45      LSLS     R10,R5,#+5
   \   0000013A   0xF10A 0x4A80      ADD      R10,R10,#+1073741824
   \   0000013E   0xF51A 0x4A10      ADDS     R10,R10,#+36864
   \   00000142   0xF8CA 0x900C      STR      R9,[R10, #+12]
     63              DMA_DLAST_SGA(CHn)  =   (uint32)( (cfg & 0x20) == 0 ? (-count)  : 0 ); //调整目的地址的附加值,主循环结束后恢复目的地址或者保持地址
   \   00000146   0xEA5F 0x6984      LSLS     R9,R4,#+26
   \   0000014A   0xD402             BMI.N    ??DMA_PORTx2BUFF_Init_5
   \   0000014C   0xF1D6 0x0900      RSBS     R9,R6,#+0
   \   00000150   0xE001             B.N      ??DMA_PORTx2BUFF_Init_6
   \                     ??DMA_PORTx2BUFF_Init_5: (+1)
   \   00000152   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??DMA_PORTx2BUFF_Init_6: (+1)
   \   00000156   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000158   0xEA5F 0x1A45      LSLS     R10,R5,#+5
   \   0000015C   0xF10A 0x4A80      ADD      R10,R10,#+1073741824
   \   00000160   0xF51A 0x4A10      ADDS     R10,R10,#+36864
   \   00000164   0xF8CA 0x9018      STR      R9,[R10, #+24]
     64              DMA_CSR(CHn)        =   (0
     65                                       | DMA_CSR_DREQ_MASK            //主循环结束后停止硬件请求
     66                                       | DMA_CSR_INTMAJOR_MASK        //主循环结束后产生中断
     67                                      );
   \   00000168   0xF05F 0x090A      MOVS     R9,#+10
   \   0000016C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000016E   0xEA5F 0x1A45      LSLS     R10,R5,#+5
   \   00000172   0xF10A 0x4A80      ADD      R10,R10,#+1073741824
   \   00000176   0xF51A 0x4A10      ADDS     R10,R10,#+36864
   \   0000017A   0xF8AA 0x901C      STRH     R9,[R10, #+28]
     68          
     69              /* 配置 DMA 触发源 */
     70              DMAMUX_CHCFG_REG(DMAMUX_BASE_PTR, CHn) = (0
     71                      | DMAMUX_CHCFG_ENBL_MASK                        /* Enable routing of DMA request */
     72                      //| DMAMUX_CHCFG_TRIG_MASK                        /* Trigger Mode: Periodic   PIT周期触发传输模式   通道1对应PIT1，必须使能PIT1，且配置相应的PIT定时触发 */
     73                      | DMAMUX_CHCFG_SOURCE((ptxn >> 5) + DMA_Port_A) /* 通道触发传输源:     */
     74                                                       );
   \   0000017E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000180   0xEA5F 0x1953      LSRS     R9,R3,#+5
   \   00000184   0xF119 0x0931      ADDS     R9,R9,#+49
   \   00000188   0xF059 0x0980      ORRS     R9,R9,#0x80
   \   0000018C   0x.... 0x....      LDR.W    R10,??DataTable3_4  ;; 0x40021000
   \   00000190   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000192   0xF805 0x900A      STRB     R9,[R5, R10]
     75          
     76              SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK << (ptxn>>5));                                                               //开启PORTx端口
   \   00000196   0x.... 0x....      LDR.W    R9,??DataTable3_5  ;; 0x40048038
   \   0000019A   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \   0000019E   0xF44F 0x7A00      MOV      R10,#+512
   \   000001A2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001A4   0xEA5F 0x1B53      LSRS     R11,R3,#+5
   \   000001A8   0xFA1A 0xFA0B      LSLS     R10,R10,R11
   \   000001AC   0xEA5A 0x0909      ORRS     R9,R10,R9
   \   000001B0   0x.... 0x....      LDR.W    R10,??DataTable3_5  ;; 0x40048038
   \   000001B4   0xF8CA 0x9000      STR      R9,[R10, #+0]
     77              GPIO_PDDR_REG(GPIOx[(ptxn>>5)]) &= ~(1 << (ptxn & 0x1f));                                                       //设置端口方向为输入
   \   000001B8   0x.... 0x....      LDR.W    R9,??DataTable3_6
   \   000001BC   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001BE   0xEA5F 0x1A63      ASRS     R10,R3,#+5
   \   000001C2   0xF859 0x902A      LDR      R9,[R9, R10, LSL #+2]
   \   000001C6   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   000001CA   0x.... 0x....      LDR.W    R9,??DataTable3_6
   \   000001CE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001D0   0xEA5F 0x1A63      ASRS     R10,R3,#+5
   \   000001D4   0xF859 0x902A      LDR      R9,[R9, R10, LSL #+2]
   \   000001D8   0xF8D9 0x9014      LDR      R9,[R9, #+20]
   \   000001DC   0xF05F 0x0B01      MOVS     R11,#+1
   \   000001E0   0xF013 0x0A1F      ANDS     R10,R3,#0x1F
   \   000001E4   0xFA1B 0xFA0A      LSLS     R10,R11,R10
   \   000001E8   0xEA39 0x0A0A      BICS     R10,R9,R10
   \   000001EC   0xF8DD 0x9000      LDR      R9,[SP, #+0]
   \   000001F0   0xF8C9 0xA014      STR      R10,[R9, #+20]
     78              PORT_PCR_REG(PORTX[(ptxn>>5)], (ptxn & 0x1F)) = ( 0
     79                      | PORT_PCR_MUX(1)               // 复用GPIO
     80                      | PORT_PCR_IRQC(cfg & 0x03 )    // 确定触发模式
     81                      | ((cfg & 0xc0 ) >> 6)          // 开启上拉或下拉电阻，或者没有
     82                                                              );
   \   000001F4   0x.... 0x....      LDR.W    R9,??DataTable3_7
   \   000001F8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001FA   0xEA5F 0x1A63      ASRS     R10,R3,#+5
   \   000001FE   0xF859 0x902A      LDR      R9,[R9, R10, LSL #+2]
   \   00000202   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000204   0xF013 0x0A1F      ANDS     R10,R3,#0x1F
   \   00000208   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   0000020C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000020E   0xF014 0x0B03      ANDS     R11,R4,#0x3
   \   00000212   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000214   0xEA5F 0x1A94      LSRS     R10,R4,#+6
   \   00000218   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000021C   0xEA5A 0x4A0B      ORRS     R10,R10,R11, LSL #+16
   \   00000220   0xF45A 0x7A80      ORRS     R10,R10,#0x100
   \   00000224   0xF8DD 0xB000      LDR      R11,[SP, #+0]
   \   00000228   0xF849 0xA02B      STR      R10,[R9, R11, LSL #+2]
     83              GPIO_PDDR_REG(GPIOx[(ptxn>>5)]) &= ~(1 << (ptxn && 0x1F));                                                      //输入模式
   \   0000022C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000022E   0x2B00             CMP      R3,#+0
   \   00000230   0xD002             BEQ.N    ??DMA_PORTx2BUFF_Init_7
   \   00000232   0xF05F 0x0B01      MOVS     R11,#+1
   \   00000236   0xE001             B.N      ??DMA_PORTx2BUFF_Init_8
   \                     ??DMA_PORTx2BUFF_Init_7: (+1)
   \   00000238   0xF05F 0x0B00      MOVS     R11,#+0
   \                     ??DMA_PORTx2BUFF_Init_8: (+1)
   \   0000023C   0x.... 0x....      LDR.W    R9,??DataTable3_6
   \   00000240   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000242   0xEA5F 0x1A63      ASRS     R10,R3,#+5
   \   00000246   0xF859 0x902A      LDR      R9,[R9, R10, LSL #+2]
   \   0000024A   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   0000024E   0x.... 0x....      LDR.W    R10,??DataTable3_6
   \   00000252   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000254   0xEA5F 0x1963      ASRS     R9,R3,#+5
   \   00000258   0xF85A 0x9029      LDR      R9,[R10, R9, LSL #+2]
   \   0000025C   0xF8D9 0x9014      LDR      R9,[R9, #+20]
   \   00000260   0xF05F 0x0A01      MOVS     R10,#+1
   \   00000264   0xFA1A 0xFA0B      LSLS     R10,R10,R11
   \   00000268   0xEA39 0x0A0A      BICS     R10,R9,R10
   \   0000026C   0xF8DD 0x9000      LDR      R9,[SP, #+0]
   \   00000270   0xF8C9 0xA014      STR      R10,[R9, #+20]
     84          
     85              /*  配置输入源   */
     86              SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK << ((((uint32)SADDR) & 0x1ff)>>6));             //开启PORTx端口
   \   00000274   0x.... 0x....      LDR.W    R9,??DataTable3_5  ;; 0x40048038
   \   00000278   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \   0000027C   0xF44F 0x7A00      MOV      R10,#+512
   \   00000280   0xEA5F 0x1B91      LSRS     R11,R1,#+6
   \   00000284   0xF01B 0x0B07      ANDS     R11,R11,#0x7
   \   00000288   0xFA1A 0xFA0B      LSLS     R10,R10,R11
   \   0000028C   0xEA5A 0x0909      ORRS     R9,R10,R9
   \   00000290   0x.... 0x....      LDR.W    R10,??DataTable3_5  ;; 0x40048038
   \   00000294   0xF8CA 0x9000      STR      R9,[R10, #+0]
     87              switch(byten)
   \   00000298   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000029A   0x2800             CMP      R0,#+0
   \   0000029C   0xD003             BEQ.N    ??DMA_PORTx2BUFF_Init_9
   \   0000029E   0x2802             CMP      R0,#+2
   \   000002A0   0xD00B             BEQ.N    ??DMA_PORTx2BUFF_Init_10
   \   000002A2   0xD305             BCC.N    ??DMA_PORTx2BUFF_Init_11
   \   000002A4   0xE00E             B.N      ??DMA_PORTx2BUFF_Init_12
     88              {
     89              case DMA_BYTE1:
     90                  *((uint8 *)((uint32)SADDR + 4)) = 0;   //设置为输入方向。为什么加4？PDIR地址加4后，就变成对应的PDDR地址
   \                     ??DMA_PORTx2BUFF_Init_9: (+1)
   \   000002A6   0xF05F 0x0900      MOVS     R9,#+0
   \   000002AA   0xF881 0x9004      STRB     R9,[R1, #+4]
     91                  break;
   \   000002AE   0xE009             B.N      ??DMA_PORTx2BUFF_Init_13
     92              case DMA_BYTE2:
     93                  *((uint16 *)((uint32)SADDR + 4)) = 0;
   \                     ??DMA_PORTx2BUFF_Init_11: (+1)
   \   000002B0   0xF05F 0x0900      MOVS     R9,#+0
   \   000002B4   0xF8A1 0x9004      STRH     R9,[R1, #+4]
     94                  break;
   \   000002B8   0xE004             B.N      ??DMA_PORTx2BUFF_Init_13
     95              case DMA_BYTE4:
     96                  *((uint32 *)((uint32)SADDR + 4)) = 0;
   \                     ??DMA_PORTx2BUFF_Init_10: (+1)
   \   000002BA   0xF05F 0x0900      MOVS     R9,#+0
   \   000002BE   0xF8C1 0x9004      STR      R9,[R1, #+4]
     97                  break;
   \   000002C2   0xE7FF             B.N      ??DMA_PORTx2BUFF_Init_13
     98              default:
     99                  
    100                  break;
    101              }
    102          
    103              /*  输入源管脚选择功能脚  */
    104              n =(uint8)(((uint32)SADDR - ((uint32)(&PTA_BYTE0_IN))) & 0x3f);         //最小的引脚号
   \                     ??DMA_PORTx2BUFF_Init_12: (+1)
   \                     ??DMA_PORTx2BUFF_Init_13: (+1)
   \   000002C4   0x4689             MOV      R9,R1
   \   000002C6   0xF1B9 0x0910      SUBS     R9,R9,#+16
   \   000002CA   0xF019 0x093F      ANDS     R9,R9,#0x3F
   \   000002CE   0x464F             MOV      R7,R9
    105              tmp = n + (BYTEs << 3);                                         //最大的引脚号
   \   000002D0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002D4   0xEA5F 0x09C8      LSLS     R9,R8,#+3
   \   000002D8   0xFA59 0xF987      UXTAB    R9,R9,R7
   \   000002DC   0x46CE             MOV      LR,R9
    106              for(i = n; i < tmp; i++)
   \   000002DE   0x46BC             MOV      R12,R7
   \                     ??DMA_PORTx2BUFF_Init_14: (+1)
   \   000002E0   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   000002E4   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   000002E8   0x45F4             CMP      R12,LR
   \   000002EA   0xD210             BCS.N    ??DMA_PORTx2BUFF_Init_15
    107              {
    108                  PORT_PCR_REG(PORTX[   ((((uint32)SADDR)&0x1ff)>>6)    ], i) = (0
    109                          | PORT_PCR_MUX(1)
    110                          | GPI_DOWN             //输入源应该下拉，默认读取到的是0
    111                                                                             );
   \   000002EC   0x.... 0x....      LDR.W    R9,??DataTable3_7
   \   000002F0   0xEA5F 0x1A91      LSRS     R10,R1,#+6
   \   000002F4   0xF01A 0x0A07      ANDS     R10,R10,#0x7
   \   000002F8   0xF859 0x902A      LDR      R9,[R9, R10, LSL #+2]
   \   000002FC   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   00000300   0xF44F 0x7A81      MOV      R10,#+258
   \   00000304   0xF849 0xA02C      STR      R10,[R9, R12, LSL #+2]
    112              }
   \   00000308   0xF11C 0x0C01      ADDS     R12,R12,#+1
   \   0000030C   0xE7E8             B.N      ??DMA_PORTx2BUFF_Init_14
    113          
    114              /* 开启中断 */
    115              //DMA_EN(CHn);                                    //使能通道CHn 硬件请求
    116              //DMA_IRQ_EN(CHn);                                //允许DMA通道传输
    117          }
   \                     ??DMA_PORTx2BUFF_Init_15: (+1)
   \   0000030E   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    118          
    119          
    120          
    121          
    122          
    123          /*************************************************************************
    124          *                             野火嵌入式开发工作室
    125          *
    126          *  函数名称：DMA_count_Init
    127          *  功能说明：DMA累加计数初始化
    128          *  参数说明：DMA_CHn              通道号（DMA_CH0 ~ DMA_CH15）
    129          *            PTxn                 触发端口
    130          *            count                累加计数中断值
    131          *            DMA_Count_cfg        DMA传输配置
    132          *  函数返回：无
    133          *  修改时间：2012-1-20
    134          *  备    注：
    135          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    136          void DMA_count_Init(DMA_CHn CHn, PTxn ptxn, uint32 count, DMA_Count_cfg cfg)
    137          {
   \                     DMA_count_Init: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
    138              uint8 byten = DMA_BYTE1;
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
    139              uint8 BYTEs = (byten == DMA_BYTE1 ? 1 : (byten == DMA_BYTE2 ? 2 : (byten == DMA_BYTE4 ? 4 : 16 ) ) ); //计算传输字节数
   \   00000010   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000014   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000018   0xD101             BNE.N    ??DMA_count_Init_0
   \   0000001A   0x2401             MOVS     R4,#+1
   \   0000001C   0xE00E             B.N      ??DMA_count_Init_1
   \                     ??DMA_count_Init_0: (+1)
   \   0000001E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000022   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000026   0xD101             BNE.N    ??DMA_count_Init_2
   \   00000028   0x2402             MOVS     R4,#+2
   \   0000002A   0xE007             B.N      ??DMA_count_Init_3
   \                     ??DMA_count_Init_2: (+1)
   \   0000002C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000030   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000034   0xD101             BNE.N    ??DMA_count_Init_4
   \   00000036   0x2404             MOVS     R4,#+4
   \   00000038   0xE000             B.N      ??DMA_count_Init_3
   \                     ??DMA_count_Init_4: (+1)
   \   0000003A   0x2410             MOVS     R4,#+16
    140              if(count > 0x7FFF )count = 0x7FFF;
   \                     ??DMA_count_Init_3: (+1)
   \                     ??DMA_count_Init_1: (+1)
   \   0000003C   0xF5B7 0x4F00      CMP      R7,#+32768
   \   00000040   0xD302             BCC.N    ??DMA_count_Init_5
   \   00000042   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000046   0x0007             MOVS     R7,R0
    141              count_init[CHn] = count;
   \                     ??DMA_count_Init_5: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable3_8
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0xF840 0x7025      STR      R7,[R0, R5, LSL #+2]
    142          
    143              /* 开启时钟 */
    144              SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;                        //打开DMA模块时钟
   \   00000050   0x....             LDR.N    R0,??DataTable3  ;; 0x40048040
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000058   0x....             LDR.N    R1,??DataTable3  ;; 0x40048040
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    145              SIM_SCGC6 |= SIM_SCGC6_DMAMUX_MASK;                     //打开DMA多路复用器时钟
   \   0000005C   0x....             LDR.N    R0,??DataTable3_1  ;; 0x4004803c
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000064   0x....             LDR.N    R1,??DataTable3_1  ;; 0x4004803c
   \   00000066   0x6008             STR      R0,[R1, #+0]
    146          
    147              /* 配置 DMA 通道 的 传输控制块 TCD ( Transfer Control Descriptor ) */
    148              DMA_SADDR(CHn) =    (uint32)COUNTSADDR;                    // 设置  源地址
   \   00000068   0x....             LDR.N    R0,??DataTable3_9  ;; 0x4004000c
   \   0000006A   0x....             LDR.N    R1,??DataTable3_2  ;; 0x40009000
   \   0000006C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006E   0x016A             LSLS     R2,R5,#+5
   \   00000070   0x5050             STR      R0,[R2, R1]
    149              DMA_DADDR(CHn) =    (uint32)COUNTDADDR;                    // 设置目的地址
   \   00000072   0x....             LDR.N    R0,??DataTable3_9  ;; 0x4004000c
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0x0169             LSLS     R1,R5,#+5
   \   00000078   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   0000007C   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000080   0x6108             STR      R0,[R1, #+16]
    150              DMA_SOFF(CHn)  =    0;                                  // 设置源地址不变
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000086   0x0169             LSLS     R1,R5,#+5
   \   00000088   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   0000008C   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000090   0x8088             STRH     R0,[R1, #+4]
    151              DMA_DOFF(CHn)  =    0;                                  // 每次传输后，目的地址不变
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000096   0x0169             LSLS     R1,R5,#+5
   \   00000098   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   0000009C   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   000000A0   0x8288             STRH     R0,[R1, #+20]
    152          
    153              DMA_ATTR(CHn)  =    (0
    154                                   | DMA_ATTR_SMOD(0x0)                // 源地址模数禁止  Source address modulo feature is disabled
    155                                   | DMA_ATTR_SSIZE(byten)             // 源数据位宽 ：DMA_BYTEn  。    SSIZE = 0 -> 8-bit ，SSIZE = 1 -> 16-bit ，SSIZE = 2 -> 32-bit ，SSIZE = 4 -> 16-byte
    156                                   | DMA_ATTR_DMOD(0x0)                // 目标地址模数禁止
    157                                   | DMA_ATTR_DSIZE(byten)             // 目标数据位宽 ：DMA_BYTEn  。  设置参考  SSIZE
    158                                  );
   \   000000A2   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000A6   0xEA5F 0x2009      LSLS     R0,R9,#+8
   \   000000AA   0xF410 0x60E0      ANDS     R0,R0,#0x700
   \   000000AE   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000B2   0xF019 0x0107      ANDS     R1,R9,#0x7
   \   000000B6   0x4308             ORRS     R0,R1,R0
   \   000000B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BA   0x0169             LSLS     R1,R5,#+5
   \   000000BC   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000000C0   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   000000C4   0x80C8             STRH     R0,[R1, #+6]
    159          
    160              DMA_CITER_ELINKNO(CHn)  = DMA_CITER_ELINKNO_CITER(count); //当前主循环次数
   \   000000C6   0x0038             MOVS     R0,R7
   \   000000C8   0x0440             LSLS     R0,R0,#+17       ;; ZeroExtS R0,R0,#+17,#+17
   \   000000CA   0x0C40             LSRS     R0,R0,#+17
   \   000000CC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CE   0x0169             LSLS     R1,R5,#+5
   \   000000D0   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000000D4   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   000000D8   0x82C8             STRH     R0,[R1, #+22]
    161              DMA_BITER_ELINKNO(CHn)  = DMA_BITER_ELINKYES_BITER(count);//起始主循环次数
   \   000000DA   0x0038             MOVS     R0,R7
   \   000000DC   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   000000DE   0x0DC0             LSRS     R0,R0,#+23
   \   000000E0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E2   0x0169             LSLS     R1,R5,#+5
   \   000000E4   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000000E8   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   000000EC   0x83C8             STRH     R0,[R1, #+30]
    162          
    163              DMA_CR &= ~DMA_CR_EMLM_MASK;                            // CR[EMLM] = 0
   \   000000EE   0x....             LDR.N    R0,??DataTable3_3  ;; 0x40008000
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0xF030 0x0080      BICS     R0,R0,#0x80
   \   000000F6   0x....             LDR.N    R1,??DataTable3_3  ;; 0x40008000
   \   000000F8   0x6008             STR      R0,[R1, #+0]
    164          
    165              DMA_NBYTES_MLNO(CHn) =   DMA_NBYTES_MLNO_NBYTES(BYTEs); // 通道每次传输字节数，这里设置为BYTEs个字节。注：值为0表示传输4GB */
   \   000000FA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FE   0x0168             LSLS     R0,R5,#+5
   \   00000100   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000104   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   00000108   0x6084             STR      R4,[R0, #+8]
    166          
    167              /* 配置 DMA 传输结束后的操作 */
    168              DMA_SLAST(CHn)      =   -count;                              //调整  源地址的附加值,主循环结束后恢复  源地址
   \   0000010A   0x4278             RSBS     R0,R7,#+0
   \   0000010C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010E   0x0169             LSLS     R1,R5,#+5
   \   00000110   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000114   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000118   0x60C8             STR      R0,[R1, #+12]
    169              DMA_DLAST_SGA(CHn)  =   0;                                  //调整目的地址的附加值,主循环结束后恢复目的地址或者保持地址
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011E   0x0169             LSLS     R1,R5,#+5
   \   00000120   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000124   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000128   0x6188             STR      R0,[R1, #+24]
    170              DMA_CSR(CHn)        =   (0
    171                                       | DMA_CSR_DREQ_MASK            //主循环结束后停止硬件请求
    172                                       | DMA_CSR_INTMAJOR_MASK        //主循环结束后产生中断
    173                                      );
   \   0000012A   0x200A             MOVS     R0,#+10
   \   0000012C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000012E   0x0169             LSLS     R1,R5,#+5
   \   00000130   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000134   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000138   0x8388             STRH     R0,[R1, #+28]
    174          
    175              /* 配置 DMA 触发源 */
    176              DMAMUX_CHCFG_REG(DMAMUX_BASE_PTR, CHn) = (0
    177                      | DMAMUX_CHCFG_ENBL_MASK                        /* Enable routing of DMA request */
    178                      | DMAMUX_CHCFG_SOURCE((ptxn >> 5) + DMA_Port_A) /* 通道触发传输源:     */
    179                                                       );
   \   0000013A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000013C   0x0970             LSRS     R0,R6,#+5
   \   0000013E   0x3031             ADDS     R0,R0,#+49
   \   00000140   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000144   0x....             LDR.N    R1,??DataTable3_4  ;; 0x40021000
   \   00000146   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000148   0x5468             STRB     R0,[R5, R1]
    180          
    181              SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK << (ptxn>>5));                                                               //开启PORTx端口
   \   0000014A   0x....             LDR.N    R0,??DataTable3_5  ;; 0x40048038
   \   0000014C   0x6800             LDR      R0,[R0, #+0]
   \   0000014E   0xF44F 0x7100      MOV      R1,#+512
   \   00000152   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000154   0x0972             LSRS     R2,R6,#+5
   \   00000156   0x4091             LSLS     R1,R1,R2
   \   00000158   0x4308             ORRS     R0,R1,R0
   \   0000015A   0x....             LDR.N    R1,??DataTable3_5  ;; 0x40048038
   \   0000015C   0x6008             STR      R0,[R1, #+0]
    182              GPIO_PDDR_REG(GPIOx[(ptxn>>5)]) &= ~(1 << (ptxn & 0x1f));                                                       //设置端口方向为输入
   \   0000015E   0x....             LDR.N    R0,??DataTable3_6
   \   00000160   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000162   0x1171             ASRS     R1,R6,#+5
   \   00000164   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000168   0x....             LDR.N    R1,??DataTable3_6
   \   0000016A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000016C   0x1172             ASRS     R2,R6,#+5
   \   0000016E   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \   00000172   0x6949             LDR      R1,[R1, #+20]
   \   00000174   0x2201             MOVS     R2,#+1
   \   00000176   0xF016 0x031F      ANDS     R3,R6,#0x1F
   \   0000017A   0x409A             LSLS     R2,R2,R3
   \   0000017C   0x4391             BICS     R1,R1,R2
   \   0000017E   0x6141             STR      R1,[R0, #+20]
    183              PORT_PCR_REG(PORTX[(ptxn>>5)], (ptxn & 0x1F)) = ( 0
    184                      | PORT_PCR_MUX(1)               // 复用GPIO
    185                      | PORT_PCR_IRQC(cfg & 0x03 )    // 确定触发模式
    186                      | ((cfg & 0xc0 ) >> 6)          // 开启上拉或下拉电阻，或者没有
    187                                                              );
   \   00000180   0x....             LDR.N    R0,??DataTable3_7
   \   00000182   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000184   0x1171             ASRS     R1,R6,#+5
   \   00000186   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   0000018A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000018C   0xF016 0x011F      ANDS     R1,R6,#0x1F
   \   00000190   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000194   0xF018 0x0203      ANDS     R2,R8,#0x3
   \   00000198   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000019C   0xEA5F 0x1398      LSRS     R3,R8,#+6
   \   000001A0   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001A2   0xEA53 0x4202      ORRS     R2,R3,R2, LSL #+16
   \   000001A6   0xF452 0x7280      ORRS     R2,R2,#0x100
   \   000001AA   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
    188              GPIO_PDDR_REG(GPIOx[(ptxn>>5)]) &= ~(1 << (ptxn && 0x1F));                                                      //输入模式
   \   000001AE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001B0   0x2E00             CMP      R6,#+0
   \   000001B2   0xD001             BEQ.N    ??DMA_count_Init_6
   \   000001B4   0x2001             MOVS     R0,#+1
   \   000001B6   0xE000             B.N      ??DMA_count_Init_7
   \                     ??DMA_count_Init_6: (+1)
   \   000001B8   0x2000             MOVS     R0,#+0
   \                     ??DMA_count_Init_7: (+1)
   \   000001BA   0x....             LDR.N    R1,??DataTable3_6
   \   000001BC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001BE   0x1172             ASRS     R2,R6,#+5
   \   000001C0   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \   000001C4   0x....             LDR.N    R2,??DataTable3_6
   \   000001C6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001C8   0x1173             ASRS     R3,R6,#+5
   \   000001CA   0xF852 0x2023      LDR      R2,[R2, R3, LSL #+2]
   \   000001CE   0x6952             LDR      R2,[R2, #+20]
   \   000001D0   0x2301             MOVS     R3,#+1
   \   000001D2   0xFA13 0xF000      LSLS     R0,R3,R0
   \   000001D6   0xEA32 0x0000      BICS     R0,R2,R0
   \   000001DA   0x6148             STR      R0,[R1, #+20]
    189          
    190              /* 开启中断 */
    191              DMA_EN(CHn);                                    //使能通道CHn 硬件请求
   \   000001DC   0x....             LDR.N    R0,??DataTable3_10  ;; 0x4000800c
   \   000001DE   0x6800             LDR      R0,[R0, #+0]
   \   000001E0   0x2101             MOVS     R1,#+1
   \   000001E2   0x40A9             LSLS     R1,R1,R5
   \   000001E4   0x4308             ORRS     R0,R1,R0
   \   000001E6   0x....             LDR.N    R1,??DataTable3_10  ;; 0x4000800c
   \   000001E8   0x6008             STR      R0,[R1, #+0]
    192              DMA_IRQ_EN(CHn);                                //允许DMA通道传输
   \   000001EA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001EC   0x0028             MOVS     R0,R5
   \   000001EE   0x.... 0x....      BL       enable_irq
    193          }
   \   000001F2   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    194          
    195          /*************************************************************************
    196          *                             野火嵌入式开发工作室
    197          *
    198          *  函数名称：DMA_count_get
    199          *  功能说明：返回累加计数值
    200          *  参数说明：DMA_CHn              通道号（DMA_CH0 ~ DMA_CH15）
    201          *  函数返回：累加计数值
    202          *  修改时间：2012-3-320
    203          *  备    注：
    204          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    205          uint32 DMA_count_get(DMA_CHn CHn)
    206          {
   \                     DMA_count_get: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    207              uint32 temp =  count_init[CHn] - DMA_CITER_ELINKNO(CHn)  ;
   \   00000002   0x....             LDR.N    R0,??DataTable3_8
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x014A             LSLS     R2,R1,#+5
   \   0000000E   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   00000012   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   00000016   0x8AD2             LDRH     R2,[R2, #+22]
   \   00000018   0x1A80             SUBS     R0,R0,R2
    208              return temp;
   \   0000001A   0x4770             BX       LR               ;; return
    209          }
    210          

   \                                 In section .text, align 2, keep-with-next
    211          void DMA_count_reset(DMA_CHn CHn)
    212          {
    213              DMA_CITER_ELINKNO(CHn) = count_init[CHn] ;
   \                     DMA_count_reset: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable3_8
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x0142             LSLS     R2,R0,#+5
   \   0000000C   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   00000010   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   00000014   0x82D1             STRH     R1,[R2, #+22]
    214          }
   \   00000016   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x40048040         DC32     0x40048040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x40009000         DC32     0x40009000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x40008000         DC32     0x40008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     GPIOx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     PORTX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     count_init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x4004000C         DC32     0x4004000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x4000800C         DC32     0x4000800c
    215          
    216          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   DMA_PORTx2BUFF_Init
      32   DMA_count_Init
        32   -> enable_irq
       0   DMA_count_get
       0   DMA_count_reset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
     786  DMA_PORTx2BUFF_Init
     502  DMA_count_Init
      28  DMA_count_get
      24  DMA_count_reset
      64  count_init

 
    64 bytes in section .bss
 1 384 bytes in section .text
 
 1 384 bytes of CODE memory
    64 bytes of DATA memory

Errors: none
Warnings: none
