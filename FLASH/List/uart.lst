###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        21/Jun/2014  20:40:01
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  L:\6.21\src\Sources\Drivers\uart\uart.c
#    Command line =  
#        L:\6.21\src\Sources\Drivers\uart\uart.c -D IAR -D TWR_K60N512 -D DEBUG
#        -lCN L:\6.21\FLASH\List\ -lB L:\6.21\FLASH\List\ -o L:\6.21\FLASH\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        D:\dowload\iark60\arm\INC\c\DLib_Config_Normal.h -I
#        L:\6.21\src\Sources\Cpu\ -I L:\6.21\src\Sources\App\ -I
#        L:\6.21\src\Sources\Drivers\adc\ -I L:\6.21\src\Sources\Drivers\delay\
#        -I L:\6.21\src\Sources\Drivers\FTM\ -I
#        L:\6.21\src\Sources\Drivers\gpio\ -I
#        L:\6.21\src\Sources\Drivers\lptmr\ -I L:\6.21\src\Sources\Drivers\mcg\
#        -I L:\6.21\src\Sources\Drivers\PIT\ -I
#        L:\6.21\src\Sources\Drivers\uart\ -I L:\6.21\src\Sources\Drivers\oled\
#        -I L:\6.21\src\Sources\Drivers\spi\ -On --use_c++_inline
#    List file    =  L:\6.21\FLASH\List\uart.lst
#    Object file  =  L:\6.21\FLASH\Obj\uart.o
#
###############################################################################

L:\6.21\src\Sources\Drivers\uart\uart.c
      1          /******************** (C) COPYRIGHT 2011 野火嵌入式开发工作室 ********************
      2           * 文件名       ：uart.c
      3           * 描述         ：串口函数
      4           * 备注         ：参考苏州大学的例程和飞思卡尔官方的例程
      5           *
      6           * 实验平台     ：野火kinetis开发板
      7           * 库版本       ：
      8           * 嵌入系统     ：
      9           *
     10           * 作者         ：
     11           * 淘宝店       ：http://firestm32.taobao.com
     12           * 技术支持论坛 ：http://www.ourdev.cn/bbs/bbs_list.jsp?bbs_id=1008
     13          **********************************************************************************/
     14          
     15          #include "common.h"
     16          #include "uart.h"
     17          #include "assert.h"
     18          

   \                                 In section .data, align 4
     19          volatile struct UART_MemMap *UARTx[6] = {UART0_BASE_PTR, UART1_BASE_PTR, UART2_BASE_PTR, UART3_BASE_PTR, UART4_BASE_PTR, UART5_BASE_PTR}; //定义五个指针数组保存 UARTx 的地址
   \                     UARTx:
   \   00000000   0x4006A000         DC32 4006A000H, 4006B000H, 4006C000H, 4006D000H, 400EA000H, 400EB000H
   \              0x4006B000   
   \              0x4006C000   
   \              0x4006D000   
   \              0x400EA000   
   \              0x400EB000   
     20          
     21          /*************************************************************************
     22          *                             野火嵌入式开发工作室
     23          *
     24          *  函数名称：uart_init
     25          *  功能说明：初始化串口，设置波特率
     26          *  参数说明：UARTn       模块号（UART0~UART5）
     27          *            baud        波特率，如9600、19200、56000、115200等
     28          *  函数返回：无
     29          *  修改时间：2012-1-20       uartclk_khz = CORE_CLOCK*10 * BUS_CLOCK;//时钟180MHz    //随时更改
     30          *  备    注：在官方例程上修改
     31          *************************************************************************/
     32          

   \                                 In section .text, align 2, keep-with-next
     33          void uart_init (UARTn uratn, uint32 baud)
     34          {
   \                     uart_init: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
     35              register uint16 sbr, brfa;
     36              uint8 temp;
     37              uint32 sysclk;     //时钟
     38          
     39              
     40              switch(uratn)
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD008             BEQ.N    ??uart_init_0
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD024             BEQ.N    ??uart_init_1
   \   0000000C   0xD314             BCC.N    ??uart_init_2
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD03F             BEQ.N    ??uart_init_3
   \   00000012   0xD32F             BCC.N    ??uart_init_4
   \   00000014   0x2805             CMP      R0,#+5
   \   00000016   0xD04B             BEQ.N    ??uart_init_5
   \   00000018   0xE059             B.N      ??uart_init_6
     41              {
     42              case UART0:
     43                  if(UART0_RX == PTA1)
     44                      PORTA_PCR1 = PORT_PCR_MUX(0x2);      //在PTA1上使能UART0_RXD
     45                  else if(UART0_RX == PTA15)
     46                      PORTA_PCR15 = PORT_PCR_MUX(0x3);     //在PTA15上使能UART0_RXD
     47                  else if(UART0_RX == PTB16)
     48                      PORTB_PCR16 = PORT_PCR_MUX(0x3);     //在PTB16上使能UART0_RXD
   \                     ??uart_init_0: (+1)
   \   0000001A   0xF44F 0x7640      MOV      R6,#+768
   \   0000001E   0x....             LDR.N    R7,??DataTable7  ;; 0x4004a040
   \   00000020   0x603E             STR      R6,[R7, #+0]
     49                  else if(UART0_RX == PTD6)
     50                      PORTD_PCR6 = PORT_PCR_MUX(0x3);      //在PTD6上使能UART0_RXD
     51          
     52                  if(UART0_TX == PTA2)
     53                      PORTA_PCR2 = PORT_PCR_MUX(0x2);     //在PTA2上使能UART0_RXD
     54                  else if(UART0_TX == PTA14)
     55                      PORTA_PCR14 = PORT_PCR_MUX(0x3);     //在PTA14上使能UART0_RXD
     56                  else if(UART0_TX == PTB17)
     57                      PORTB_PCR17 = PORT_PCR_MUX(0x3);     //在PTB17上使能UART0_RXD
   \   00000022   0xF44F 0x7640      MOV      R6,#+768
   \   00000026   0x....             LDR.N    R7,??DataTable7_1  ;; 0x4004a044
   \   00000028   0x603E             STR      R6,[R7, #+0]
     58                  else if(UART0_TX == PTD7)
     59                      PORTD_PCR7 = PORT_PCR_MUX(0x3);     //在PTD7上使能UART0_RXD
     60          
     61                  SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;      //使能 UARTn 时钟
   \   0000002A   0x....             LDR.N    R6,??DataTable7_2  ;; 0x40048034
   \   0000002C   0x6836             LDR      R6,[R6, #+0]
   \   0000002E   0xF456 0x6680      ORRS     R6,R6,#0x400
   \   00000032   0x....             LDR.N    R7,??DataTable7_2  ;; 0x40048034
   \   00000034   0x603E             STR      R6,[R7, #+0]
     62                  break;
   \   00000036   0xE04A             B.N      ??uart_init_7
     63          
     64              case UART1:
     65                  if(UART1_RX == PTC3)
     66                      PORTC_PCR3 = PORT_PCR_MUX(0x3);     //在PTC3上使能UART1_RXD
   \                     ??uart_init_2: (+1)
   \   00000038   0xF44F 0x7640      MOV      R6,#+768
   \   0000003C   0x....             LDR.N    R7,??DataTable7_3  ;; 0x4004b00c
   \   0000003E   0x603E             STR      R6,[R7, #+0]
     67                  else if(UART1_RX == PTE1)
     68                      PORTE_PCR1 = PORT_PCR_MUX(0x3);     //在PTE1上使能UART1_RXD
     69                  
     70          
     71                  if(UART1_TX == PTC4)
     72                      PORTC_PCR4 = PORT_PCR_MUX(0x3);     //在PTC4上使能UART1_RXD
   \   00000040   0xF44F 0x7640      MOV      R6,#+768
   \   00000044   0x....             LDR.N    R7,??DataTable7_4  ;; 0x4004b010
   \   00000046   0x603E             STR      R6,[R7, #+0]
     73                  else if(UART1_TX == PTE0)
     74                      PORTE_PCR0 = PORT_PCR_MUX(0x3);     //在PTE0上使能UART1_RXD
     75                 
     76          
     77                  SIM_SCGC4 |= SIM_SCGC4_UART1_MASK;
   \   00000048   0x....             LDR.N    R6,??DataTable7_2  ;; 0x40048034
   \   0000004A   0x6836             LDR      R6,[R6, #+0]
   \   0000004C   0xF456 0x6600      ORRS     R6,R6,#0x800
   \   00000050   0x....             LDR.N    R7,??DataTable7_2  ;; 0x40048034
   \   00000052   0x603E             STR      R6,[R7, #+0]
     78                  break;
   \   00000054   0xE03B             B.N      ??uart_init_7
     79          
     80              case UART2:
     81                  PORTD_PCR3 = PORT_PCR_MUX(0x3);         //在PTD3上使能UART2_TXD功能
   \                     ??uart_init_1: (+1)
   \   00000056   0xF44F 0x7640      MOV      R6,#+768
   \   0000005A   0x....             LDR.N    R7,??DataTable7_5  ;; 0x4004c00c
   \   0000005C   0x603E             STR      R6,[R7, #+0]
     82                  PORTD_PCR2 = PORT_PCR_MUX(0x3);         //在PTD2上使能UART2_RXD
   \   0000005E   0xF44F 0x7640      MOV      R6,#+768
   \   00000062   0x....             LDR.N    R7,??DataTable7_6  ;; 0x4004c008
   \   00000064   0x603E             STR      R6,[R7, #+0]
     83                  SIM_SCGC4 |= SIM_SCGC4_UART2_MASK;
   \   00000066   0x....             LDR.N    R6,??DataTable7_2  ;; 0x40048034
   \   00000068   0x6836             LDR      R6,[R6, #+0]
   \   0000006A   0xF456 0x5680      ORRS     R6,R6,#0x1000
   \   0000006E   0x....             LDR.N    R7,??DataTable7_2  ;; 0x40048034
   \   00000070   0x603E             STR      R6,[R7, #+0]
     84                  break;
   \   00000072   0xE02C             B.N      ??uart_init_7
     85          
     86              case UART3:
     87                  if(UART3_RX == PTB10)
     88                      PORTB_PCR10 = PORT_PCR_MUX(0x3);     //在PTB10上使能UART3_RXD
     89                  else if(UART3_RX == PTC16)
     90                      PORTC_PCR16 = PORT_PCR_MUX(0x3);     //在PTC16上使能UART3_RXD
   \                     ??uart_init_4: (+1)
   \   00000074   0xF44F 0x7640      MOV      R6,#+768
   \   00000078   0x....             LDR.N    R7,??DataTable7_7  ;; 0x4004b040
   \   0000007A   0x603E             STR      R6,[R7, #+0]
     91                  else if(UART3_RX == PTE5)
     92                      PORTE_PCR5 = PORT_PCR_MUX(0x3);      //在PTE5上使能UART3_RXD
     93                          
     94          
     95                  if(UART3_TX == PTB11)
     96                      PORTB_PCR11 = PORT_PCR_MUX(0x3);     //在PTB11上使能UART3_RXD
     97                  else if(UART3_TX == PTC17)
     98                      PORTC_PCR17 = PORT_PCR_MUX(0x3);     //在PTC17上使能UART3_RXD
   \   0000007C   0xF44F 0x7640      MOV      R6,#+768
   \   00000080   0x....             LDR.N    R7,??DataTable7_8  ;; 0x4004b044
   \   00000082   0x603E             STR      R6,[R7, #+0]
     99                  else if(UART3_TX == PTE4)
    100                      PORTE_PCR4 = PORT_PCR_MUX(0x3);     //在PTE4上使能UART3_RXD
    101               
    102                  SIM_SCGC4 |= SIM_SCGC4_UART3_MASK;
   \   00000084   0x....             LDR.N    R6,??DataTable7_2  ;; 0x40048034
   \   00000086   0x6836             LDR      R6,[R6, #+0]
   \   00000088   0xF456 0x5600      ORRS     R6,R6,#0x2000
   \   0000008C   0x....             LDR.N    R7,??DataTable7_2  ;; 0x40048034
   \   0000008E   0x603E             STR      R6,[R7, #+0]
    103                  break;
   \   00000090   0xE01D             B.N      ??uart_init_7
    104          
    105              case UART4:
    106                  if(UART4_RX == PTC14)
    107                      PORTC_PCR14 = PORT_PCR_MUX(0x3);     //在PTC14上使能UART4_RXD
    108                  else if(UART4_RX == PTE25)
    109                      PORTE_PCR25 = PORT_PCR_MUX(0x3);     //在PTE25上使能UART4_RXD
   \                     ??uart_init_3: (+1)
   \   00000092   0xF44F 0x7640      MOV      R6,#+768
   \   00000096   0x....             LDR.N    R7,??DataTable7_9  ;; 0x4004d064
   \   00000098   0x603E             STR      R6,[R7, #+0]
    110                 
    111                  if(UART4_TX == PTC15)
    112                      PORTC_PCR15 = PORT_PCR_MUX(0x3);     //在PTC15上使能UART4_RXD
    113                  else if(UART4_TX == PTE24)
    114                      PORTE_PCR24 = PORT_PCR_MUX(0x3);     //在PTE24上使能UART4_RXD
   \   0000009A   0xF44F 0x7640      MOV      R6,#+768
   \   0000009E   0x....             LDR.N    R7,??DataTable7_10  ;; 0x4004d060
   \   000000A0   0x603E             STR      R6,[R7, #+0]
    115                               //设置管脚有误？
    116          
    117                  SIM_SCGC1 |= SIM_SCGC1_UART4_MASK;
   \   000000A2   0x....             LDR.N    R6,??DataTable7_11  ;; 0x40048028
   \   000000A4   0x6836             LDR      R6,[R6, #+0]
   \   000000A6   0xF456 0x6680      ORRS     R6,R6,#0x400
   \   000000AA   0x....             LDR.N    R7,??DataTable7_11  ;; 0x40048028
   \   000000AC   0x603E             STR      R6,[R7, #+0]
    118                  break;
   \   000000AE   0xE00E             B.N      ??uart_init_7
    119          
    120              case UART5:
    121                  if(UART5_RX == PTD8)
    122                      PORTD_PCR8 = PORT_PCR_MUX(0x3);     //在PTD8上使能UART5_RXD
    123                  else if(UART5_RX == PTE9)
    124                      PORTE_PCR9 = PORT_PCR_MUX(0x3);     //在PTE9上使能UART5_RXD
   \                     ??uart_init_5: (+1)
   \   000000B0   0xF44F 0x7640      MOV      R6,#+768
   \   000000B4   0x....             LDR.N    R7,??DataTable7_12  ;; 0x4004d024
   \   000000B6   0x603E             STR      R6,[R7, #+0]
    125                  
    126                  if(UART5_TX == PTD9)
    127                      PORTD_PCR9 = PORT_PCR_MUX(0x3);     //在PTD9上使能UART5_RXD
    128                  else if(UART5_TX == PTE8)
    129                      PORTE_PCR8 = PORT_PCR_MUX(0x3);     //在PTE8上使能UART5_RXD
   \   000000B8   0xF44F 0x7640      MOV      R6,#+768
   \   000000BC   0x....             LDR.N    R7,??DataTable7_13  ;; 0x4004d020
   \   000000BE   0x603E             STR      R6,[R7, #+0]
    130                  
    131                  SIM_SCGC1 |= SIM_SCGC1_UART5_MASK;
   \   000000C0   0x....             LDR.N    R6,??DataTable7_11  ;; 0x40048028
   \   000000C2   0x6836             LDR      R6,[R6, #+0]
   \   000000C4   0xF456 0x6600      ORRS     R6,R6,#0x800
   \   000000C8   0x....             LDR.N    R7,??DataTable7_11  ;; 0x40048028
   \   000000CA   0x603E             STR      R6,[R7, #+0]
    132                  break;
   \   000000CC   0xE7FF             B.N      ??uart_init_7
    133              default:
    134                  break;
    135              }
    136          
    137          
    138              //设置的时候，应该禁止发送接受
    139              UART_C2_REG(UARTx[uratn]) &= ~(UART_C2_TE_MASK  | UART_C2_RE_MASK );
   \                     ??uart_init_6: (+1)
   \                     ??uart_init_7: (+1)
   \   000000CE   0x....             LDR.N    R6,??DataTable7_14
   \   000000D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D2   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   000000D6   0x78F6             LDRB     R6,[R6, #+3]
   \   000000D8   0xF016 0x06F3      ANDS     R6,R6,#0xF3
   \   000000DC   0x....             LDR.N    R7,??DataTable7_14
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
   \   000000E4   0x70FE             STRB     R6,[R7, #+3]
    140          
    141              //配置成8位无校验模式
    142              //设置 UART 数据格式、校验方式和停止位位数。通过设置 UART 模块控制寄存器 C1 实现；
    143              UART_C1_REG(UARTx[uratn]) = 0;	// 全部直接使用默认设置就行，所以直接清0
   \   000000E6   0x2600             MOVS     R6,#+0
   \   000000E8   0x....             LDR.N    R7,??DataTable7_14
   \   000000EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EC   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
   \   000000F0   0x70BE             STRB     R6,[R7, #+2]
    144          
    145              //计算波特率，串口0、1使用内核时钟，其它串口使用外设时钟
    146              if ((uratn == UART0) | (uratn == UART1))
   \   000000F2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD101             BNE.N    ??uart_init_8
   \   000000F8   0x2601             MOVS     R6,#+1
   \   000000FA   0xE000             B.N      ??uart_init_9
   \                     ??uart_init_8: (+1)
   \   000000FC   0x2600             MOVS     R6,#+0
   \                     ??uart_init_9: (+1)
   \   000000FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000100   0x2801             CMP      R0,#+1
   \   00000102   0xD101             BNE.N    ??uart_init_10
   \   00000104   0x2701             MOVS     R7,#+1
   \   00000106   0xE000             B.N      ??uart_init_11
   \                     ??uart_init_10: (+1)
   \   00000108   0x2700             MOVS     R7,#+0
   \                     ??uart_init_11: (+1)
   \   0000010A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000010C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000010E   0x433E             ORRS     R6,R7,R6
   \   00000110   0x2E00             CMP      R6,#+0
   \   00000112   0xD002             BEQ.N    ??uart_init_12
    147                  sysclk = core_clk_khz * 1000;            //内核时钟//
   \   00000114   0x....             LDR.N    R6,??DataTable7_15  ;; 0xaba9500
   \   00000116   0x0035             MOVS     R5,R6
   \   00000118   0xE001             B.N      ??uart_init_13
    148              else
    149                  sysclk = bus_clk_khz * 1000;  //外设时钟
   \                     ??uart_init_12: (+1)
   \   0000011A   0x....             LDR.N    R6,??DataTable7_16  ;; 0x55d4a80
   \   0000011C   0x0035             MOVS     R5,R6
    150          
    151              //设置 UART 数据通讯波特率。通过设置 UART 模块的波特率寄存器
    152              sbr = (uint16)(sysclk / (baud << 4));
   \                     ??uart_init_13: (+1)
   \   0000011E   0x010E             LSLS     R6,R1,#+4
   \   00000120   0xFBB5 0xF6F6      UDIV     R6,R5,R6
   \   00000124   0x0032             MOVS     R2,R6
    153          
    154             
    155              temp = UART_BDH_REG(UARTx[uratn]) & ~(UART_BDH_SBR(0x1F));
   \   00000126   0x....             LDR.N    R6,??DataTable7_14
   \   00000128   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012A   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   0000012E   0x7836             LDRB     R6,[R6, #+0]
   \   00000130   0xF016 0x06E0      ANDS     R6,R6,#0xE0
   \   00000134   0x0034             MOVS     R4,R6
    156          
    157              UART_BDH_REG(UARTx[uratn]) = temp |  UART_BDH_SBR(((sbr & 0x1F00) >> 8));
   \   00000136   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000138   0x0A16             LSRS     R6,R2,#+8
   \   0000013A   0xF016 0x061F      ANDS     R6,R6,#0x1F
   \   0000013E   0x4326             ORRS     R6,R6,R4
   \   00000140   0x....             LDR.N    R7,??DataTable7_14
   \   00000142   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000144   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
   \   00000148   0x703E             STRB     R6,[R7, #+0]
    158              UART_BDL_REG(UARTx[uratn]) = (uint8)(sbr & UART_BDL_SBR_MASK);
   \   0000014A   0x....             LDR.N    R6,??DataTable7_14
   \   0000014C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014E   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   00000152   0x7072             STRB     R2,[R6, #+1]
    159          
    160              //brfa = (((sysclk*32)/(baud * 16)) - (sbr * 32));
    161              brfa = (((sysclk << 5) / (baud << 4)) - (sbr << 5));
   \   00000154   0x016E             LSLS     R6,R5,#+5
   \   00000156   0x010F             LSLS     R7,R1,#+4
   \   00000158   0xFBB6 0xF6F7      UDIV     R6,R6,R7
   \   0000015C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000015E   0xEBB6 0x1642      SUBS     R6,R6,R2, LSL #+5
   \   00000162   0x0033             MOVS     R3,R6
    162          
    163            
    164              temp = UART_C4_REG(UARTx[uratn]) & ~(UART_C4_BRFA(0x1F));
   \   00000164   0x....             LDR.N    R6,??DataTable7_14
   \   00000166   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000168   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   0000016C   0x7AB6             LDRB     R6,[R6, #+10]
   \   0000016E   0xF016 0x06E0      ANDS     R6,R6,#0xE0
   \   00000172   0x0034             MOVS     R4,R6
    165          
    166              UART_C4_REG(UARTx[uratn]) = temp |  UART_C4_BRFA(brfa);
   \   00000174   0xF013 0x061F      ANDS     R6,R3,#0x1F
   \   00000178   0x4326             ORRS     R6,R6,R4
   \   0000017A   0x....             LDR.N    R7,??DataTable7_14
   \   0000017C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000017E   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
   \   00000182   0x72BE             STRB     R6,[R7, #+10]
    167          
    168             
    169              UART_C2_REG(UARTx[uratn]) |= (UART_C2_TE_MASK | UART_C2_RE_MASK );
   \   00000184   0x....             LDR.N    R6,??DataTable7_14
   \   00000186   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000188   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   0000018C   0x78F6             LDRB     R6,[R6, #+3]
   \   0000018E   0xF056 0x060C      ORRS     R6,R6,#0xC
   \   00000192   0x....             LDR.N    R7,??DataTable7_14
   \   00000194   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000196   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
   \   0000019A   0x70FE             STRB     R6,[R7, #+3]
    170          
    171              //设置是否允许接收和发送中断。通过设置 UART 模块的 C2 寄存器的
    172              //RIE 和 TIE 位实现。如果使能中断，必须首先实现中断服务程序；
    173          }
   \   0000019C   0xBCF0             POP      {R4-R7}
   \   0000019E   0x4770             BX       LR               ;; return
    174          
    175          /*************************************************************************
    176          *                             野火嵌入式开发工作室
    177          *
    178          *  函数名称：uart_getchar
    179          *  功能说明：无限时间等待串口接受一个字节
    180          *  参数说明：UARTn       模块号（UART0~UART5）
    181          *  函数返回：接收到的字节
    182          *  修改时间：2012-1-20
    183          *  备    注：官方例程
    184          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    185          char uart_getchar (UARTn uratn)
    186          {
    187              /* Wait until character has been received */
    188              while (!(UART_S1_REG(UARTx[uratn]) & UART_S1_RDRF_MASK));
   \                     uart_getchar: (+1)
   \                     ??uart_getchar_0: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_14
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000008   0x7909             LDRB     R1,[R1, #+4]
   \   0000000A   0x0689             LSLS     R1,R1,#+26
   \   0000000C   0xD5F8             BPL.N    ??uart_getchar_0
    189          
    190              /* Return the 8-bit data from the receiver */
    191              return UART_D_REG(UARTx[uratn]);
   \   0000000E   0x....             LDR.N    R1,??DataTable7_14
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000016   0x79C0             LDRB     R0,[R0, #+7]
   \   00000018   0x4770             BX       LR               ;; return
    192          }
    193          
    194          /*************************************************************************
    195          *                             野火嵌入式开发工作室
    196          *
    197          *  函数名称：uart_pendchar
    198          *  功能说明：有限时间等待串口接受一个字节
    199          *  参数说明：UARTn       模块号（UART0~UART5）
    200          *  函数返回：接收到的字节
    201          *  修改时间：2012-1-20
    202          *  备    注：
    203          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    204          char uart_pendchar (UARTn uratn, char *ch)
    205          {
   \                     uart_pendchar: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    206              uint32 i = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    207          
    208              while(++i < 0xffffff)                                         //时间限制
   \                     ??uart_pendchar_0: (+1)
   \   00000004   0x1C5B             ADDS     R3,R3,#+1
   \   00000006   0xF07F 0x407F      MVNS     R0,#-16777216
   \   0000000A   0x4283             CMP      R3,R0
   \   0000000C   0xD20E             BCS.N    ??uart_pendchar_1
    209              {
    210                  if(UART_S1_REG(UARTx[uratn]) & UART_S1_RDRF_MASK)         //查询是否接受到数据
   \   0000000E   0x....             LDR.N    R0,??DataTable7_14
   \   00000010   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000012   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \   00000016   0x7900             LDRB     R0,[R0, #+4]
   \   00000018   0x0680             LSLS     R0,R0,#+26
   \   0000001A   0xD5F3             BPL.N    ??uart_pendchar_0
    211                  {
    212                      *ch  =   UART_D_REG(UARTx[uratn]);                    //接受到8位的数据
   \   0000001C   0x....             LDR.N    R0,??DataTable7_14
   \   0000001E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \   00000024   0x79C0             LDRB     R0,[R0, #+7]
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    213                      return  1;                                            //返回 1 表示接收成功
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE002             B.N      ??uart_pendchar_2
    214                  }
    215              }
    216          
    217              *ch = 0;                                                     //接收不到，应该清空了接收区
   \                     ??uart_pendchar_1: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    218              return 0;                                                    //返回0表示接收失败
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??uart_pendchar_2: (+1)
   \   00000032   0x4770             BX       LR               ;; return
    219          }
    220          
    221          /*************************************************************************
    222          *  函数名称：uart_pendchar
    223          *  功能说明：有限时间等待串口接受一个字节
    224          *  参数说明：UARTn       模块号（UART0~UART5）
    225          *  函数返回：接收到的字节
    226          *  修改时间：2012-1-20
    227          *  备    注：
    228          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    229          char uart_pendchar1 (UARTn uratn)
    230          {
    231             
    232              
    233                
    234                      return UART_D_REG(UARTx[uratn]);                    //接受到8位的数据 
   \                     uart_pendchar1: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_14
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0x79C0             LDRB     R0,[R0, #+7]
   \   0000000A   0x4770             BX       LR               ;; return
    235                     
    236                                                                                     
    237          }
    238          
    239          
    240          /*************************************************************************
    241          *                             野火嵌入式开发工作室
    242          *
    243          *  函数名称：uart_pendstr
    244          *  功能说明：有限时间等待串口接受字符串
    245          *  参数说明：UARTn       模块号（UART0~UART5）
    246          *  函数返回：接收到的字节
    247          *  修改时间：2012-1-20
    248          *  备    注：
    249          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    250          char uart_pendstr (UARTn uratn, char *str)
    251          {
   \                     uart_pendstr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    252              uint32 i = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    253              while(uart_pendchar(uratn, str + i++));
   \                     ??uart_pendstr_0: (+1)
   \   00000008   0x1971             ADDS     R1,R6,R5
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       uart_pendchar
   \   00000012   0x1C76             ADDS     R6,R6,#+1
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD1F6             BNE.N    ??uart_pendstr_0
    254          
    255              return (i <= 1 ? 0 : 1);
   \   0000001A   0x2E02             CMP      R6,#+2
   \   0000001C   0xD201             BCS.N    ??uart_pendstr_1
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE000             B.N      ??uart_pendstr_2
   \                     ??uart_pendstr_1: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \                     ??uart_pendstr_2: (+1)
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
    256          }
    257          
    258          
    259          
    260          /*************************************************************************
    261          *                             野火嵌入式开发工作室
    262          *
    263          *  函数名称：uart_putchar
    264          *  功能说明：串口发送一个字节
    265          *  参数说明：UARTn       模块号（UART0~UART5）
    266          *  函数返回：无
    267          *  修改时间：2012-1-20
    268          *  备    注：官方例程，printf会调用这函数
    269          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    270          void uart_putchar (UARTn uratn, char ch)
    271          {
    272              //等待发送缓冲区空
    273              while(!(UART_S1_REG(UARTx[uratn]) & UART_S1_TDRE_MASK));
   \                     uart_putchar: (+1)
   \                     ??uart_putchar_0: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable7_14
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000008   0x7912             LDRB     R2,[R2, #+4]
   \   0000000A   0x0612             LSLS     R2,R2,#+24
   \   0000000C   0xD5F8             BPL.N    ??uart_putchar_0
    274              //发送数据
    275              UART_D_REG(UARTx[uratn]) = (uint8)ch;
   \   0000000E   0x....             LDR.N    R2,??DataTable7_14
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000016   0x71D1             STRB     R1,[R2, #+7]
    276          }
   \   00000018   0x4770             BX       LR               ;; return
    277          
    278          
    279          
    280          /*************************************************************************
    281          *                             野火嵌入式开发工作室
    282          *
    283          *  函数名称：uart_query
    284          *  功能说明：查询是否接受到一个字节
    285          *  参数说明：UARTn       模块号（UART0~UART5）
    286          *  函数返回：1           接收到一个字节了
    287          *            0           没有接收到
    288          *  修改时间：2012-1-20
    289          *  备    注：官方例程
    290          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    291          int uart_query (UARTn uratn)
    292          {
    293              return (UART_S1_REG(UARTx[uratn]) & UART_S1_RDRF_MASK);
   \                     uart_query: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_14
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0x7900             LDRB     R0,[R0, #+4]
   \   0000000A   0xF010 0x0020      ANDS     R0,R0,#0x20
   \   0000000E   0x4770             BX       LR               ;; return
    294          }
    295          
    296          /*************************************************************************
    297          *                             野火嵌入式开发工作室
    298          *
    299          *  函数名称：uart_sendN
    300          *  功能说明：串行 发送指定len个字节长度字符串 （包括 NULL 也会发送）
    301          *  参数说明：UARTn       模块号（UART0~UART5）
    302          *            buff        发送缓冲区
    303          *            len         发送长度
    304          *  函数返回：无
    305          *  修改时间：2012-1-20
    306          *  备    注：
    307          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    308          void uart_sendN (UARTn uratn, uint8 *buff, uint16 len)
    309          {
   \                     uart_sendN: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    310              int i;
    311              for(i = 0; i < len; i++)
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0007             MOVS     R7,R0
   \                     ??uart_sendN_0: (+1)
   \   0000000C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000E   0x42B7             CMP      R7,R6
   \   00000010   0xDA06             BGE.N    ??uart_sendN_1
    312              {
    313                  uart_putchar(uratn, buff[i]);
   \   00000012   0x5D79             LDRB     R1,[R7, R5]
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       uart_putchar
    314              }
   \   0000001C   0x1C7F             ADDS     R7,R7,#+1
   \   0000001E   0xE7F5             B.N      ??uart_sendN_0
    315          }
   \                     ??uart_sendN_1: (+1)
   \   00000020   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    316          
    317          /*************************************************************************
    318          *                             野火嵌入式开发工作室
    319          *
    320          *  函数名称：uart_sendStr
    321          *  功能说明：串行发送字符串
    322          *  参数说明：UARTn       模块号（UART0~UART5）
    323          *            str         字符串
    324          *  函数返回：无
    325          *  修改时间：2012-1-20
    326          *  备    注：
    327          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    328          void uart_sendStr (UARTn uratn, const uint8 *str)
    329          {
   \                     uart_sendStr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    330              while(*str)
   \                     ??uart_sendStr_0: (+1)
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??uart_sendStr_1
    331              {
    332                  uart_putchar(uratn, *str++);
   \   0000000C   0x7829             LDRB     R1,[R5, #+0]
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       uart_putchar
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \   00000018   0xE7F5             B.N      ??uart_sendStr_0
    333              }
    334          }
   \                     ??uart_sendStr_1: (+1)
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    335          
    336          /*************************************************************************
    337          *                             野火嵌入式开发工作室
    338          *
    339          *  函数名称：uart_irq_EN
    340          *  功能说明：开串口接收中断
    341          *  参数说明：UARTn       模块号（UART0~UART5）
    342          *  函数返回：无
    343          *  修改时间：2012-1-20
    344          *  备    注：
    345          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    346          void uart_irq_EN(UARTn uratn)
    347          {
   \                     uart_irq_EN: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    348              UART_C2_REG(UARTx[uratn]) |= UART_C2_RIE_MASK;    //开放UART接收中断
   \   00000004   0x....             LDR.N    R0,??DataTable7_14
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000000C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000000E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000012   0x....             LDR.N    R1,??DataTable7_14
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000001A   0x70C8             STRB     R0,[R1, #+3]
    349              enable_irq((uratn << 1) + 45);			        //开接收引脚的IRQ中断
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x0060             LSLS     R0,R4,#+1
   \   00000020   0x302D             ADDS     R0,R0,#+45
   \   00000022   0x.... 0x....      BL       enable_irq
    350          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    351          
    352          
    353          /*************************************************************************
    354          *                             野火嵌入式开发工作室
    355          *
    356          *  函数名称：uart_irq_DIS
    357          *  功能说明：关串口接收中断
    358          *  参数说明：UARTn       模块号（UART0~UART5）
    359          *  函数返回：无
    360          *  修改时间：2012-1-20
    361          *  备    注：
    362          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    363          void uart_irq_DIS(UARTn uratn)
    364          {
   \                     uart_irq_DIS: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    365              UART_C2_REG(UARTx[uratn]) &= ~UART_C2_RIE_MASK;   //禁止UART接收中断
   \   00000004   0x....             LDR.N    R0,??DataTable7_14
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000000C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000000E   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000012   0x....             LDR.N    R1,??DataTable7_14
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000001A   0x70C8             STRB     R0,[R1, #+3]
    366              disable_irq((uratn << 1) + 45);			        //关接收引脚的IRQ中断
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x0060             LSLS     R0,R4,#+1
   \   00000020   0x302D             ADDS     R0,R0,#+45
   \   00000022   0x.... 0x....      BL       disable_irq
    367          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x4004A040         DC32     0x4004a040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x4004A044         DC32     0x4004a044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x4004B00C         DC32     0x4004b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x4004B010         DC32     0x4004b010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x4004C00C         DC32     0x4004c00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x4004C008         DC32     0x4004c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x4004B040         DC32     0x4004b040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x4004B044         DC32     0x4004b044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x4004D064         DC32     0x4004d064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x4004D060         DC32     0x4004d060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x40048028         DC32     0x40048028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x4004D024         DC32     0x4004d024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x4004D020         DC32     0x4004d020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_14:
   \   00000000   0x........         DC32     UARTx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_15:
   \   00000000   0x0ABA9500         DC32     0xaba9500

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_16:
   \   00000000   0x055D4A80         DC32     0x55d4a80
    368          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   uart_getchar
      16   uart_init
       8   uart_irq_DIS
         8   -> disable_irq
       8   uart_irq_EN
         8   -> enable_irq
       0   uart_pendchar
       0   uart_pendchar1
      16   uart_pendstr
        16   -> uart_pendchar
       0   uart_putchar
       0   uart_query
      24   uart_sendN
        24   -> uart_putchar
      16   uart_sendStr
        16   -> uart_putchar


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_16
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
      24  UARTx
      26  uart_getchar
     416  uart_init
      40  uart_irq_DIS
      40  uart_irq_EN
      52  uart_pendchar
      12  uart_pendchar1
      40  uart_pendstr
      26  uart_putchar
      16  uart_query
      34  uart_sendN
      28  uart_sendStr

 
  24 bytes in section .data
 798 bytes in section .text
 
 798 bytes of CODE memory
  24 bytes of DATA memory

Errors: none
Warnings: none
