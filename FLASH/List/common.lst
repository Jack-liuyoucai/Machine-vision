###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        21/Jun/2014  20:39:54
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  L:\6.21\src\Sources\Cpu\common.c
#    Command line =  
#        L:\6.21\src\Sources\Cpu\common.c -D IAR -D TWR_K60N512 -D DEBUG -lCN
#        L:\6.21\FLASH\List\ -lB L:\6.21\FLASH\List\ -o L:\6.21\FLASH\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        D:\dowload\iark60\arm\INC\c\DLib_Config_Normal.h -I
#        L:\6.21\src\Sources\Cpu\ -I L:\6.21\src\Sources\App\ -I
#        L:\6.21\src\Sources\Drivers\adc\ -I L:\6.21\src\Sources\Drivers\delay\
#        -I L:\6.21\src\Sources\Drivers\FTM\ -I
#        L:\6.21\src\Sources\Drivers\gpio\ -I
#        L:\6.21\src\Sources\Drivers\lptmr\ -I L:\6.21\src\Sources\Drivers\mcg\
#        -I L:\6.21\src\Sources\Drivers\PIT\ -I
#        L:\6.21\src\Sources\Drivers\uart\ -I L:\6.21\src\Sources\Drivers\oled\
#        -I L:\6.21\src\Sources\Drivers\spi\ -On --use_c++_inline
#    List file    =  L:\6.21\FLASH\List\common.lst
#    Object file  =  L:\6.21\FLASH\Obj\common.o
#
###############################################################################

L:\6.21\src\Sources\Cpu\common.c
      1          //-------------------------------------------------------------------------*
      2          // 文件名: common.h (通用头文件)                                           *
      3          // 说  明:                                                                 *
      4          //-------------------------------------------------------------------------*
      5          
      6          #include "common.h"
      7          
      8          //-------------------------------------------------------------------------*
      9          //函数名: stop                                                             *
     10          //功  能: 设置CPU为STOP模式                                                * 
     11          //参  数: 无								   *	
     12          //返  回: 无                                                               *
     13          //说  明: 无                                                               *
     14          //-------------------------------------------------------------------------*

   \                                 In section .text, align 4, keep-with-next
     15          void stop (void)
     16          {
     17              //置位SLEEPDEEP来使能STOP模式
     18              SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
   \                     stop: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4  ;; 0xe000ed10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000008   0x....             LDR.N    R1,??DataTable4  ;; 0xe000ed10
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     19              //进入STOP模式
     20              asm("WFI");
   \   0000000C   0xBF30             WFI
     21          }
   \   0000000E   0x4770             BX       LR               ;; return
     22          
     23          //-------------------------------------------------------------------------*
     24          //函数名: wait                                                             *
     25          //功  能: 设置CPU为WAIT模式                                                * 
     26          //参  数: 无								   *	
     27          //返  回: 无                                                               *
     28          //说  明: 无                                                               *
     29          //-------------------------------------------------------------------------*

   \                                 In section .text, align 4, keep-with-next
     30          void wait (void)
     31          {
     32              //清SLEEPDEEP位来确定进入WAIT模式
     33              SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;	
   \                     wait: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4  ;; 0xe000ed10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000008   0x....             LDR.N    R1,??DataTable4  ;; 0xe000ed10
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     34              //进入WAIT模式
     35              asm("WFI");
   \   0000000C   0xBF30             WFI
     36          }
   \   0000000E   0x4770             BX       LR               ;; return
     37          
     38          //-------------------------------------------------------------------------*
     39          //函数名: write_vtor                                                       *
     40          //功  能: 更改中断向量表偏移寄存器的值                                     * 
     41          //参  数: 要更改的值    						   *	
     42          //返  回: 无                                                               *
     43          //说  明: 无                                                               *
     44          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
     45          void write_vtor (int vtor)
     46          {
     47              //写新值
     48              SCB_VTOR = vtor;	
   \                     write_vtor: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable4_1  ;; 0xe000ed08
   \   00000002   0x6008             STR      R0,[R1, #+0]
     49          }
   \   00000004   0x4770             BX       LR               ;; return
     50          
     51          //-------------------------------------------------------------------------*
     52          //函数名: enable_irq                                                       *
     53          //功  能: 使能irq中断                                                      * 
     54          //参  数: irq:irq号       						   *	
     55          //返  回: 无                                                               *
     56          //说  明: irq号不是中断向量号                                              *
     57          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
     58          void enable_irq (int irq)
     59          {
   \                     enable_irq: (+1)
   \   00000000   0xB410             PUSH     {R4}
     60              int div;
     61          
     62              //确定irq号为有效的irq号
     63              if (irq > 91)	irq=91;
   \   00000002   0x285C             CMP      R0,#+92
   \   00000004   0xDB01             BLT.N    ??enable_irq_0
   \   00000006   0x225B             MOVS     R2,#+91
   \   00000008   0x0010             MOVS     R0,R2
     64              
     65              //确定对应的NVICISER
     66              div = irq/32;
   \                     ??enable_irq_0: (+1)
   \   0000000A   0x2220             MOVS     R2,#+32
   \   0000000C   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \   00000010   0x0011             MOVS     R1,R2
     67              
     68              switch (div)
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD003             BEQ.N    ??enable_irq_1
   \   00000016   0x2902             CMP      R1,#+2
   \   00000018   0xD027             BEQ.N    ??enable_irq_2
   \   0000001A   0xD313             BCC.N    ??enable_irq_3
   \   0000001C   0xE037             B.N      ??enable_irq_4
     69              {
     70              	case 0x0:
     71                        NVICICPR0 = 1 << (irq%32);
   \                     ??enable_irq_1: (+1)
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x2320             MOVS     R3,#+32
   \   00000022   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   00000026   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   0000002A   0x40A2             LSLS     R2,R2,R4
   \   0000002C   0x....             LDR.N    R3,??DataTable4_2  ;; 0xe000e280
   \   0000002E   0x601A             STR      R2,[R3, #+0]
     72                        NVICISER0 = 1 << (irq%32);
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x2320             MOVS     R3,#+32
   \   00000034   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   00000038   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   0000003C   0x40A2             LSLS     R2,R2,R4
   \   0000003E   0x....             LDR.N    R3,??DataTable4_3  ;; 0xe000e100
   \   00000040   0x601A             STR      R2,[R3, #+0]
     73                        break;
   \   00000042   0xE024             B.N      ??enable_irq_4
     74              	case 0x1:
     75                        NVICICPR1 = 1 << (irq%32);
   \                     ??enable_irq_3: (+1)
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x2320             MOVS     R3,#+32
   \   00000048   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   0000004C   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   00000050   0x40A2             LSLS     R2,R2,R4
   \   00000052   0x....             LDR.N    R3,??DataTable4_4  ;; 0xe000e284
   \   00000054   0x601A             STR      R2,[R3, #+0]
     76                        NVICISER1 = 1 << (irq%32);
   \   00000056   0x2201             MOVS     R2,#+1
   \   00000058   0x2320             MOVS     R3,#+32
   \   0000005A   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   0000005E   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   00000062   0x40A2             LSLS     R2,R2,R4
   \   00000064   0x....             LDR.N    R3,??DataTable4_5  ;; 0xe000e104
   \   00000066   0x601A             STR      R2,[R3, #+0]
     77                        break;
   \   00000068   0xE011             B.N      ??enable_irq_4
     78              	case 0x2:
     79                        NVICICPR2 = 1 << (irq%32);
   \                     ??enable_irq_2: (+1)
   \   0000006A   0x2201             MOVS     R2,#+1
   \   0000006C   0x2320             MOVS     R3,#+32
   \   0000006E   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   00000072   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   00000076   0x40A2             LSLS     R2,R2,R4
   \   00000078   0x....             LDR.N    R3,??DataTable4_6  ;; 0xe000e288
   \   0000007A   0x601A             STR      R2,[R3, #+0]
     80                        NVICISER2 = 1 << (irq%32);
   \   0000007C   0x2201             MOVS     R2,#+1
   \   0000007E   0x2320             MOVS     R3,#+32
   \   00000080   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   00000084   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   00000088   0x40A2             LSLS     R2,R2,R4
   \   0000008A   0x....             LDR.N    R3,??DataTable4_7  ;; 0xe000e108
   \   0000008C   0x601A             STR      R2,[R3, #+0]
     81                        break;
     82              }              
     83          }
   \                     ??enable_irq_4: (+1)
   \   0000008E   0xBC10             POP      {R4}
   \   00000090   0x4770             BX       LR               ;; return
     84          
     85          //-------------------------------------------------------------------------*
     86          //函数名: disable_irq                                                      *
     87          //功  能: 禁止irq中断                                                      * 
     88          //参  数: irq:irq号       						   *	
     89          //返  回: 无                                                               *
     90          //说  明: irq号不是中断向量号                                              *
     91          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
     92          void disable_irq (int irq)
     93          {
   \                     disable_irq: (+1)
   \   00000000   0xB410             PUSH     {R4}
     94              int div;
     95              
     96              //确定irq号为有效的irq号
     97              if (irq > 91)	irq=91;
   \   00000002   0x285C             CMP      R0,#+92
   \   00000004   0xDB01             BLT.N    ??disable_irq_0
   \   00000006   0x225B             MOVS     R2,#+91
   \   00000008   0x0010             MOVS     R0,R2
     98              
     99              //确定对应的NVICISER
    100              div = irq/32;
   \                     ??disable_irq_0: (+1)
   \   0000000A   0x2220             MOVS     R2,#+32
   \   0000000C   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \   00000010   0x0011             MOVS     R1,R2
    101              
    102              switch (div)
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD003             BEQ.N    ??disable_irq_1
   \   00000016   0x2902             CMP      R1,#+2
   \   00000018   0xD015             BEQ.N    ??disable_irq_2
   \   0000001A   0xD30A             BCC.N    ??disable_irq_3
   \   0000001C   0xE01C             B.N      ??disable_irq_4
    103              {
    104              	case 0x0:
    105                         NVICICER0 = 1 << (irq%32);
   \                     ??disable_irq_1: (+1)
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x2320             MOVS     R3,#+32
   \   00000022   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   00000026   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   0000002A   0x40A2             LSLS     R2,R2,R4
   \   0000002C   0x....             LDR.N    R3,??DataTable4_8  ;; 0xe000e180
   \   0000002E   0x601A             STR      R2,[R3, #+0]
    106                        break;
   \   00000030   0xE012             B.N      ??disable_irq_4
    107              	case 0x1:
    108                        NVICICER1 = 1 << (irq%32);
   \                     ??disable_irq_3: (+1)
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x2320             MOVS     R3,#+32
   \   00000036   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   0000003A   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   0000003E   0x40A2             LSLS     R2,R2,R4
   \   00000040   0x....             LDR.N    R3,??DataTable4_9  ;; 0xe000e184
   \   00000042   0x601A             STR      R2,[R3, #+0]
    109                        break;
   \   00000044   0xE008             B.N      ??disable_irq_4
    110              	case 0x2:
    111                        NVICICER2 = 1 << (irq%32);
   \                     ??disable_irq_2: (+1)
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x2320             MOVS     R3,#+32
   \   0000004A   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   0000004E   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   00000052   0x40A2             LSLS     R2,R2,R4
   \   00000054   0x....             LDR.N    R3,??DataTable4_10  ;; 0xe000e188
   \   00000056   0x601A             STR      R2,[R3, #+0]
    112                        break;
    113              }              
    114          }
   \                     ??disable_irq_4: (+1)
   \   00000058   0xBC10             POP      {R4}
   \   0000005A   0x4770             BX       LR               ;; return
    115           
    116          //-------------------------------------------------------------------------*
    117          //函数名: set_irq_priority                                                 *
    118          //功  能: 设置irq中断和优先级                                              * 
    119          //参  数: irq:irq号         						   *	
    120          //        prio:优先级						           *	
    121          //返  回: 无                                                               *
    122          //说  明: irq号不是中断向量号                                              *
    123          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
    124          void set_irq_priority (int irq, int prio)
    125          {
    126              uint8 *prio_reg;
    127          
    128              //确定irq号和优先级有效
    129              if (irq > 91)	irq=91;
   \                     set_irq_priority: (+1)
   \   00000000   0x285C             CMP      R0,#+92
   \   00000002   0xDB01             BLT.N    ??set_irq_priority_0
   \   00000004   0x235B             MOVS     R3,#+91
   \   00000006   0x0018             MOVS     R0,R3
    130              if (prio > 15)	prio=15;
   \                     ??set_irq_priority_0: (+1)
   \   00000008   0x2910             CMP      R1,#+16
   \   0000000A   0xDB01             BLT.N    ??set_irq_priority_1
   \   0000000C   0x230F             MOVS     R3,#+15
   \   0000000E   0x0019             MOVS     R1,R3
    131          
    132              //确定对应的NVICISER
    133              prio_reg = (uint8 *)(((uint32)&NVICIP0) + irq);
   \                     ??set_irq_priority_1: (+1)
   \   00000010   0xF100 0x4360      ADD      R3,R0,#-536870912
   \   00000014   0xF513 0x4364      ADDS     R3,R3,#+58368
   \   00000018   0x001A             MOVS     R2,R3
    134              //设置优先级
    135              *prio_reg = ( (prio&0xF) << (8 - ARM_INTERRUPT_LEVEL_BITS) );             
   \   0000001A   0x010B             LSLS     R3,R1,#+4
   \   0000001C   0x7013             STRB     R3,[R2, #+0]
    136          }
   \   0000001E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0xE000ED08         DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0xE000E284         DC32     0xe000e284

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0xE000E104         DC32     0xe000e104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0xE000E288         DC32     0xe000e288

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0xE000E108         DC32     0xe000e108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0xE000E184         DC32     0xe000e184

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0xE000E188         DC32     0xe000e188
    137          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   disable_irq
       4   enable_irq
       0   set_irq_priority
       0   stop
       0   wait
       0   write_vtor


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      92  disable_irq
     146  enable_irq
      32  set_irq_priority
      16  stop
      16  wait
       6  write_vtor

 
 352 bytes in section .text
 
 352 bytes of CODE memory

Errors: none
Warnings: none
